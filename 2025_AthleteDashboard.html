<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swimmer Performance Dashboard</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="shared-utils.js"></script>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            background-color: #f8f8f8;
            color: #333;
        }

        /* Centering and max-width for the entire dashboard */
        .container {
            max-width: 875px; /* Adjusted max width */
            margin: 20px auto; /* Center the container horizontally */
            background-color: #ffffff; /* Explicitly set background for the container */
            padding: 20px; /* Add some padding inside the container */
            border-radius: 8px; /* Rounded corners for the main container */
            box-shadow: 0 4px 10px rgba(0,0,0,0.1); /* Subtle shadow for the container */
        }

        h1 {
            text-align: center;
            color: #0156B3;
            font-size: 2em;
            margin-bottom: 10px;
            font-weight: bold;
            text-shadow: none;
        }

        .dashboard-intro-text {
            text-align: center;
            margin-bottom: 20px;
            color: #555;
            font-size: 0.9em;
            line-height: 1.4;
        }

        .filter-section {
            background-color: #f8f8f8;
            padding: 10px;
            text-align: center;
            z-index: 10;
            border-bottom: 1px solid #ccc;
            font-size: 0.8em; /* Slightly larger for main filters */
            border-radius: 8px;
            margin-bottom: 15px; /* Space between filter section and charts */
        }

        .filter-box {
            display: inline-block;
            margin: 0 4px;
            vertical-align: bottom; /* Align input with label */
        }

        label {
            font-weight: bold;
            display: block;
            margin-bottom: 6px;
        }

        select, input[type="text"] {
            padding: 3px 6px;
            font-size: 0.8em; /* Adjusted font size for inputs */
            border-radius: 4px;
            border: 1px solid #ccc;
            min-width: 150px; /* Ensure inputs have a decent size */
        }

        button {
            padding: 4px 8px;
            font-size: 0.7em;
            border-radius: 4px;
            background-color: #0156B3;
            color: white;
            border: none;
            cursor: pointer;
        }

        /* Dashboard Specific Styles */
        .chart-section {
            background-color: #e5f1ff; /* Light blue background for the dashboard section */
            padding: 15px;
            border-radius: 8px;
            margin-top: 20px;
            border: 1px solid #0156B3; /* Border with theme blue */
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .chart-section h2 {
            color: #0156B3; /* Heading color for dashboard section */
            text-align: center;
            font-size: 1.5em; /* Adjust relative to body font size */
            margin-bottom: 15px;
        }
        .chart-section h3 {
            color: #333; /* Sub-heading color */
            font-size: 1.1em;
            margin-bottom: 10px;
            text-align: center; /* Center chart titles */
        }
        .chart-controls-inner { /* New class for specific chart controls */
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            justify-content: center;
            margin-bottom: 20px;
            text-align: center;
        }
        .chart-controls-inner .dropdown-box {
            flex-grow: 0;
            min-width: unset;
            width: auto;
            text-align: center;
        }

        .chart-display {
            display: grid;
            grid-template-columns: 1fr; /* Always stack for small width */
            gap: 20px;
        }
        
        /* Base chart container for consistent padding and shadow */
        .chart-canvas-container {
            background-color: #ffffff;
            padding: 25px 15px 30px 15px; /* Top, Right/Left, Bottom */
            border-radius: 8px;
            border: 1px solid #b3d9ff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.08);
            display: flex;
            flex-direction: column;
            align-items: center;
            /* No fixed height here, individual heights will be set or default to content */
            width: 500px; /* Set fixed width for all chart containers */
            margin: 0 auto; /* Center individual chart containers */
            position: relative; /* Needed for overlay */
        }

        /* Specific height for Specialty Chart container */
        .specialty-chart-container {
            height: 500px; /* Increased for more pronounced effect */
        }

        /* Specific height for Progression Chart container */
        .progression-chart-container {
            height: 600px; /* Increased for more pronounced effect */
        }

        /* Ensure canvases maintain their size regardless of container padding */
        .chart-canvas-container canvas {
            max-width: 100%;
            max-height: 384px; /* Set a fixed max height for the canvas itself */
            width: 100% !important; /* Ensure canvas fills width if smaller */
            height: 384px !important; /* Force canvas to original intended height */
        }

        /* Styles for search result dropdown */
        .autocomplete-container {
            position: relative;
            display: inline-block; /* Allows it to be centered like a filter-box */
            width: auto; /* Adjust as needed */
        }

        .autocomplete-items {
            position: absolute;
            border: 1px solid #d4d4d4;
            border-bottom: none;
            border-top: none;
            z-index: 99;
            top: 100%;
            left: 0;
            right: 0;
            max-height: 200px;
            overflow-y: auto;
            background-color: #fff;
            text-align: left;
        }

        .autocomplete-items div {
            padding: 8px;
            cursor: pointer;
            background-color: #fff; 
            border-bottom: 1px solid #d4d4d4; 
            font-size: 0.8em;
        }

        .autocomplete-items div:hover {
            background-color: #e9e9e9;
        }

        .autocomplete-active {
            background-color: DodgerBlue !important;
            color: #ffffff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Swimmer Performance Dashboard</h1>
        <p class="dashboard-intro-text">
            Please select a swimmer to view their overall swim specialty. 
            You can then use the progression chart to track their performance over time for a specific stroke or event.
        </p>

        <div class="filter-section">
            <div class="filter-box autocomplete-container" style="text-align: center;">
                <label for="filterSwimmerName">Search Swimmer:</label>
                <input type="text" id="filterSwimmerName" placeholder="Start typing name...">
                <div id="swimmerSearchResults" class="autocomplete-items"></div>
            </div>
        </div>

        <div class="chart-section">
            <div class="chart-display">
                <div class="chart-canvas-container specialty-chart-container">
                    <h3>Swimmer Specialty (Radar Chart)</h3>
                    <canvas id="specialtyChart"></canvas>
                </div>

                <div class="chart-canvas-container progression-chart-container">
                    <h3>Time Progression (Line Chart)</h3>
                    <div class="chart-controls-inner" style="margin-top: 0; margin-bottom: 10px;">
                        <div class="dropdown-box">
                            <label for="selectEventForProgression">Select Event:</label>
                            <select id="selectEventForProgression" disabled>
                                <option value="">-- Select an Event --</option>
                                </select>
                        </div>
                    </div>
                    <canvas id="progressionChart"></canvas>
                    </div>
            </div>
        </div>
    </div>

    <script>
        let allAthleteData = [];
        let uniqueSwimmersData = []; // Store unique swimmer objects for search functionality
        let currentSelectedSwimmerId = null;

        const filterSwimmerNameInput = document.getElementById('filterSwimmerName');
        const swimmerSearchResultsDiv = document.getElementById('swimmerSearchResults');
        const selectEventForProgression = document.getElementById('selectEventForProgression');


        let specialtyChartInstance = null;
        let progressionChartInstance = null;

        // Using shared-utils.js for helper functions (timeToSeconds, secondsToTime, formatDate, formatMMDDYYYY, weeklyFileNames)
        // Ensure shared-utils.js is correctly linked in the <head>

        // --- GLOBAL CONSTANTS FOR FIXED X-AXIS ---
        // Define the start date for Week 00 (e.g., the Monday of the first competition week)
        const SEASON_START_DATE = new Date('2025-06-23T00:00:00'); 
        const WEEK_LABELS = [
            'Week 00', 'Week 01', 'Week 02', 'Week 03', 'Week 04', 
            'Week 05', 'Week 06', 'Week 07'
        ];

        // --- HELPER FUNCTION: Maps a date to a week label ---
        function getWeekLabel(dateString) {
            const meetDate = new Date(dateString + 'T00:00:00'); // Ensure UTC to avoid timezone issues
            const diffTime = Math.abs(meetDate.getTime() - SEASON_START_DATE.getTime());
            const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24)); 
            const weekNumber = Math.floor(diffDays / 7);

            if (weekNumber < WEEK_LABELS.length) {
                return WEEK_LABELS[weekNumber];
            }
            return `Week ${weekNumber}`; // Fallback for weeks beyond defined labels
        }


        function transformRawData(rawValues, fieldNames) {
            const transformed = [];
            const lastNameIndex = fieldNames.indexOf('last_name');
            const firstNameIndex = fieldNames.indexOf('first_name');
            const genderIndex = fieldNames.indexOf('competition_category');
            const ageIndex = fieldNames.indexOf('age');
            const meetDateIndex = fieldNames.indexOf('meet_date');
            const meetNameIndex = fieldNames.indexOf('meet_name');
            const eventSwumIndex = fieldNames.indexOf('event_swum');
            const seedTimeIndex = fieldNames.indexOf('seed_time');
            const resultTimeIndex = fieldNames.indexOf('result_time');
            const placeIndex = fieldNames.indexOf('place');
            const pointsIndex = fieldNames.indexOf('points');

            rawValues.forEach((row) => {
                const athleteId = `${row[lastNameIndex]}-${row[firstNameIndex]}-${row[ageIndex]}`;
                
                transformed.push({
                    id: athleteId,
                    lastName: row[lastNameIndex],
                    firstName: row[firstNameIndex],
                    category: row[genderIndex],
                    age: row[ageIndex],
                    meetDate: row[meetDateIndex],
                    meetName: String(row[meetNameIndex]).replace('2025 ', ''),
                    eventSwum: row[eventSwumIndex],
                    seedTime: String(row[seedTimeIndex]),
                    resultTime: String(row[resultTimeIndex]),
                    place: row[placeIndex],
                    points: row[pointsIndex]
                });
            });
            return transformed;
        }

        async function loadAllAthleteDataForDashboard() {
            const allFetchedRawDataPromises = weeklyFileNames.map(async (name) => {
                const filePath = new URL(name, window.location.href).toString();
                let rawWeekData = null;
                try {
                    const response = await fetch(filePath);
                    if (!response.ok) {
                        console.warn(`Could not fetch ${filePath}. Skipping this week.`);
                        return [];
                    }
                    rawWeekData = await response.json();
                    if (rawWeekData && rawWeekData.values && rawWeekData.fields) {
                        return transformRawData(rawWeekData.values, rawWeekData.fields);
                    }
                    return [];
                } catch (error) {
                    console.error(`Error fetching ${filePath}:`, error);
                    console.warn(`Skipping ${name} due to network error.`);
                    return [];
                }
            });

            const allWeeksTransformedData = await Promise.all(allFetchedRawDataPromises);
            allAthleteData = allWeeksTransformedData.flat();
            console.log("All athlete data loaded:", allAthleteData.length, "records."); 

            // Populate uniqueSwimmersData for search functionality
            const swimmerMap = new Map();
            allAthleteData.forEach(athlete => {
                const key = `${athlete.lastName}-${athlete.firstName}-${athlete.age}`;
                if (!swimmerMap.has(key)) {
                    swimmerMap.set(key, {
                        id: key,
                        firstName: athlete.firstName,
                        lastName: athlete.lastName,
                        age: athlete.age 
                    });
                }
            });
            uniqueSwimmersData = Array.from(swimmerMap.values()).sort((a, b) => 
                a.lastName.localeCompare(b.lastName) || a.firstName.localeCompare(b.firstName)
            );
            console.log("Unique swimmers prepared:", uniqueSwimmersData.length); 

            // Initialize empty charts on load
            updateSpecialtyChart(null); 
            updateProgressionChart(null, null); 
        }

        function populateEventSelectForProgression(swimmerId) {
            console.log("populateEventSelectForProgression called for swimmerId:", swimmerId);
            selectEventForProgression.innerHTML = '<option value="">-- Select an Event --</option>';
            selectEventForProgression.disabled = true;

            if (!swimmerId) {
                updateProgressionChart(null, null); 
                return;
            }

            const swimmerEvents = [...new Set(allAthleteData.filter(d => d.id === swimmerId).map(d => d.eventSwum))];
            
            console.log("Swimmer events found for progression:", swimmerEvents); 

            if (swimmerEvents.length > 0) {
                swimmerEvents.sort().forEach(event => {
                    const option = document.createElement('option');
                    option.value = event;
                    option.textContent = event;
                    selectEventForProgression.appendChild(option);
                });
                selectEventForProgression.disabled = false;

                selectEventForProgression.value = swimmerEvents[0]; 
                console.log("Auto-selecting first event for progression:", selectEventForProgression.value); 
                updateProgressionChart(swimmerId, selectEventForProgression.value);
                
            } else {
                console.warn("No events found for selected swimmer.");
                updateProgressionChart(null, null); 
            }
        }

        // --- Chart Data & Update Functions ---
        function getSpecialtyChartData(swimmerId) {
            if (!swimmerId) {
                return {
                    labels: ['Freestyle', 'Backstroke', 'Breaststroke', 'Butterfly', 'IM'],
                    datasets: [{
                        label: 'No Swimmer Selected',
                        backgroundColor: 'rgba(200, 200, 200, 0.2)',
                        borderColor: 'rgba(150, 150, 150, 1)',
                        data: [0, 0, 0, 0, 0], 
                        borderWidth: 1,
                        pointBackgroundColor: 'rgba(150, 150, 150, 1)'
                    }]
                };
            }

            const swimmerData = allAthleteData.filter(d => d.id === swimmerId);
            if (swimmerData.length === 0) {
                console.error("No data found for specialty chart for swimmerId:", swimmerId); 
                return { 
                    labels: ['Freestyle', 'Backstroke', 'Breaststroke', 'Butterfly', 'IM'],
                    datasets: [{
                        label: 'No Data for Swimmer',
                        backgroundColor: 'rgba(200, 200, 200, 0.2)',
                        borderColor: 'rgba(150, 150, 150, 1)',
                        data: [0, 0, 0, 0, 0],
                        borderWidth: 1,
                        pointBackgroundColor: 'rgba(150, 150, 150, 1)'
                    }]
                };
            }

            const strokes = ['Freestyle', 'Backstroke', 'Breaststroke', 'Butterfly', 'IM'];
            const specialtyScores = {};
            strokes.forEach(stroke => {
                const relevantEvents = swimmerData.filter(d => d.eventSwum.toLowerCase().includes(stroke.toLowerCase()) && d.resultTime !== 'NT' && d.resultTime !== 'NS' && d.resultTime !== 'DQ');
                if (relevantEvents.length > 0) {
                    const sumTimes = relevantEvents.reduce((sum, d) => sum + timeToSeconds(d.resultTime), 0);
                    const avgTime = sumTimes / relevantEvents.length;

                    const max_expected_avg_time = 120; 
                    let score = (max_expected_avg_time - avgTime) / max_expected_avg_time * 100;
                    score = Math.max(0, Math.min(100, score));
                    specialtyScores[stroke] = score;
                } else {
                    specialtyScores[stroke] = 0;
                }
            });

            const swimmerInfo = uniqueSwimmersData.find(s => s.id === swimmerId);
            const swimmerDisplayName = swimmerInfo ? `${swimmerInfo.lastName}, ${swimmerInfo.firstName}` : "Selected Swimmer";

            return {
                labels: strokes,
                datasets: [{
                    label: `${swimmerDisplayName}'s Specialty`,
                    backgroundColor: 'rgba(255, 204, 0, 0.4)',
                    borderColor: 'rgba(255, 204, 0, 1)',
                    data: strokes.map(stroke => specialtyScores[stroke]),
                    borderWidth: 1,
                    pointBackgroundColor: 'rgba(255, 204, 0, 1)'
                }]
            };
        }

        function getProgressionChartData(swimmerId, eventSwum) {
            console.log("getProgressionChartData called with swimmerId:", swimmerId, "eventSwum:", eventSwum);

            if (!swimmerId || !eventSwum) {
                // Return data structure with empty labels but default settings
                return { labels: [], datasets: [{ label: 'No Event Selected', data: [], fill: false, borderColor: 'rgba(150, 150, 150, 1)', tension: 0.1, pointBackgroundColor: 'rgba(150, 150, 150, 1)' }] };
            }

            const swimmerEventData = allAthleteData
                .filter(d => d.id === swimmerId && d.eventSwum === eventSwum && d.resultTime !== 'NT' && d.resultTime !== 'NS' && d.resultTime !== 'DQ')
                .sort((a, b) => new Date(a.meetDate) - new Date(b.meetDate));

            console.log("Filtered swimmerEventData for progression:", swimmerEventData); 

            // Create labels and data directly from sorted event data
            const labels = swimmerEventData.map(d => `${formatMMDDYYYY(d.meetDate)} (${d.meetName})`);
            const dataPoints = swimmerEventData.map(d => timeToSeconds(d.resultTime));
            
            return {
                labels: labels, // Use actual meet dates as labels
                datasets: [{
                    label: `${eventSwum}`, // Only event name, removed "Time Progression" part
                    data: dataPoints, 
                    fill: false, 
                    borderColor: '#4169E1',
                    tension: 0.4, // Set tension for rounded line
                    pointBackgroundColor: '#4169E1',
                    // spanGaps is not needed when plotting all points directly on a dynamic axis
                }]
            };
        }

        function updateSpecialtyChart(swimmerId) {
            const chartData = getSpecialtyChartData(swimmerId);
            const ctx = document.getElementById('specialtyChart').getContext('2d');

            if (specialtyChartInstance) {
                specialtyChartInstance.data = chartData;
                specialtyChartInstance.update();
            } else {
                specialtyChartInstance = new Chart(ctx, {
                    type: 'radar',
                    data: chartData,
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            r: {
                                angleLines: { color: '#e2e8f0' },
                                grid: { color: '#cbd5e0' },
                                pointLabels: {
                                    font: { size: 10, weight: 'bold' },
                                    color: '#4a5568'
                                },
                                min: 0,
                                max: 100,
                                ticks: { 
                                    display: false 
                                },
                            }
                        },
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top',
                                labels: { color: '#4a5568', font: { size: 10 } }
                            },
                            title: { display: false },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `${context.dataset.label}: ${context.raw.toFixed(1)}`;
                                    }
                                },
                                bodyFont: { size: 10 }
                            }
                        }
                    }
                });
            }
        }

        function updateProgressionChart(swimmerId, selectedEvent) {
            console.log("updateProgressionChart called with swimmerId:", swimmerId, "selectedEvent:", selectedEvent); 
            const chartData = getProgressionChartData(swimmerId, selectedEvent);
            const ctx = document.getElementById('progressionChart').getContext('2d');

            if (!ctx) {
                console.error("Canvas context for progressionChart not found.");
                return;
            }

            let yAxisMin;
            let yAxisMax; 
            let tickStepSize; 

            const dataValues = chartData.datasets[0].data.filter(d => d !== null); 
            const actualDataPointsCount = dataValues.length; 

            if (actualDataPointsCount === 0) { 
                yAxisMin = 0; 
                yAxisMax = 60; 
                tickStepSize = 10;
                console.log("No actual data points for progression chart. Using default Y-axis range (0-60s).");
            } else { 
                const minData = Math.min(...dataValues);
                const maxData = Math.max(...dataValues);

                const valueRange = maxData - minData;

                // Determine tickStepSize based on the range first
                if (valueRange <= 0.2) { 
                    tickStepSize = 0.05; 
                } else if (valueRange <= 0.5) { 
                    tickStepSize = 0.1; 
                } else if (valueRange <= 1.5) { 
                    tickStepSize = 0.25; 
                } else if (valueRange <= 5) { 
                    tickStepSize = 0.5; 
                } else { 
                    tickStepSize = 1.0; 
                }

                // Calculate yAxisMin: one tick below the minimum data point, aligned to tickStepSize
                yAxisMin = Math.floor(minData / tickStepSize) * tickStepSize;
                if (yAxisMin === minData && minData > 0) { 
                    yAxisMin = Math.max(0, yAxisMin - tickStepSize);
                } else if (minData > 0) { 
                    yAxisMin = Math.floor(minData / tickStepSize) * tickStepSize;
                } else { 
                    yAxisMin = 0;
                }

                // Calculate yAxisMax: at least five ticks above the maximum data point, aligned to tickStepSize
                const minTicksAboveMax = 5;
                let targetMax = maxData + (minTicksAboveMax * tickStepSize);
                yAxisMax = Math.ceil(targetMax / tickStepSize) * tickStepSize;

                // Ensure the range is not too tight if only one point
                if (actualDataPointsCount === 1) {
                    // Ensure a reasonable visual spread around the single point
                    const desiredRange = tickStepSize * 5; // e.g., 5 tick steps total
                    let tempMin = dataValues[0] - (desiredRange / 2);
                    let tempMax = dataValues[0] + (desiredRange / 2);

                    yAxisMin = Math.floor(tempMin / tickStepSize) * tickStepSize;
                    yAxisMax = Math.ceil(tempMax / tickStepSize) * tickStepSize;

                    if (yAxisMin < 0) yAxisMin = 0;

                    if (yAxisMax - yAxisMin < tickStepSize * 4) { 
                        const neededIncrease = (tickStepSize * 4) - (yAxisMax - yAxisMin);
                        yAxisMax += neededIncrease;
                        yAxisMax = Math.ceil(yAxisMax / tickStepSize) * tickStepSize; 
                    }
                }

                if (yAxisMin < 0) yAxisMin = 0; 

                console.log("Progression Y-axis range:", {min: yAxisMin, max: yAxisMax, step: tickStepSize});
            }
            
            const newOptions = {
                responsive: true,
                maintainAspectRatio: false,
                scales: {
                    x: {
                        title: { display: true, text: 'Meet Date (Meet Name)', color: '#4a5568', font: { size: 10 } }, 
                        labels: chartData.labels, 
                        ticks: { 
                            color: '#4a5568', 
                            font: { size: 9 },
                            display: true 
                        },
                        grid: { color: '#e2e8f0' }
                    },
                    y: {
                        title: { display: true, text: 'Time (MM:SS.ms)', color: '#4a5568', font: { size: 10 } },
                        ticks: {
                            color: '#4a5568',
                            callback: function(value) { return secondsToTime(value); },
                            font: { size: 9 },
                            stepSize: tickStepSize 
                        },
                        grid: { color: '#e2e8f0' },
                        reverse: true, 
                        min: yAxisMin,
                        max: yAxisMax
                    }
                },
                plugins: {
                    legend: {
                        display: true,
                        position: 'top',
                        labels: { color: '#4a5568', font: { size: 10 } }
                    },
                    title: { display: false },
                    tooltip: {
                        callbacks: {
                            title: function(tooltipItems) {
                                // tooltipItems[0].label contains "DATE (Meet Name)"
                                const fullLabel = tooltipItems[0].label;
                                const parts = fullLabel.split(' (');
                                const datePart = parts[0];
                                const meetNamePart = parts.length > 1 ? parts[1].replace(')', '') : ''; 
                                
                                // Return an array of strings for multi-line title.
                                // The titleFont option will apply bolding to these lines.
                                return [datePart, meetNamePart]; 
                            },
                            label: function(context) {
                                const eventLabel = context.dataset.label; 
                                const time = secondsToTime(context.raw);
                                // Return an array for multiline label content
                                return [
                                    `Event: ${eventLabel}`,
                                    `Time: ${time}`
                                ];
                            },
                        },
                        bodyFont: { size: 10 },
                        titleFont: { size: 12, weight: 'bold' }, 
                        padding: 10,
                    }
                }
            };

            if (progressionChartInstance) {
                console.log("Updating existing progressionChartInstance.");
                progressionChartInstance.data = chartData;
                progressionChartInstance.options = newOptions; 
                progressionChartInstance.update();
            } else {
                console.log("Creating new progressionChartInstance.");
                progressionChartInstance = new Chart(ctx, {
                    type: 'line',
                    data: chartData,
                    options: newOptions
                });
            }
        }

        // --- Autocomplete/Search Logic ---
        filterSwimmerNameInput.addEventListener('input', function() {
            const inputVal = this.value.toLowerCase();
            closeAllLists();
            if (!inputVal) { 
                updateChartsAndEventsForSwimmer(null); 
                return false; 
            }
            
            let currentFocus = -1;
            const matches = uniqueSwimmersData.filter(swimmer => 
                `${swimmer.firstName} ${swimmer.lastName}`.toLowerCase().includes(inputVal) ||
                `${swimmer.lastName}, ${swimmer.firstName}`.toLowerCase().includes(inputVal)
            );

            matches.forEach((swimmer, i) => {
                const itemDiv = document.createElement("div");
                itemDiv.innerHTML = `<strong>${swimmer.lastName}</strong>, ${swimmer.firstName} (${swimmer.age})`;
                itemDiv.innerHTML += `<input type='hidden' value='${swimmer.id}'>`;
                itemDiv.addEventListener("click", function() {
                    filterSwimmerNameInput.value = `${swimmer.lastName}, ${swimmer.firstName} (${swimmer.age})`;
                    currentSelectedSwimmerId = swimmer.id;
                    updateChartsAndEventsForSwimmer(currentSelectedSwimmerId);
                    closeAllLists();
                });
                swimmerSearchResultsDiv.appendChild(itemDiv);
            });
        });

        filterSwimmerNameInput.addEventListener('keydown', function(e) {
            let x = swimmerSearchResultsDiv.getElementsByTagName("div");
            if (e.keyCode == 40) { // Arrow Down
                currentFocus++;
                addActive(x);
            } else if (e.keyCode == 38) { // Arrow Up
                currentFocus--;
                addActive(x);
            } else if (e.keyCode == 13) { // Enter
                e.preventDefault();
                if (currentFocus > -1) {
                    if (x && x[currentFocus]) x[currentFocus].click();
                } else if (swimmerSearchResultsDiv.children.length > 0) {
                    // If no explicit selection but results exist, auto-select the first
                    swimmerSearchResultsDiv.children[0].click();
                }
            }
        });

        function addActive(x) {
            if (!x || x.length === 0) return false;
            removeActive(x);
            if (currentFocus >= x.length) currentFocus = 0;
            if (currentFocus < 0) currentFocus = (x.length - 1);
            x[currentFocus].classList.add("autocomplete-active");
        }

        function removeActive(x) {
            if (!x) return;
            for (let i = 0; i < x.length; i++) {
                x[i].classList.remove("autocomplete-active");
            }
        }

        function closeAllLists(elmnt) {
            const items = document.getElementsByClassName("autocomplete-items");
            for (let i = 0; i < items.length; i++) {
                if (elmnt != items[i] && elmnt != filterSwimmerNameInput) {
                    items[i].innerHTML = ''; 
                }
            }
        }

        document.addEventListener("click", function (e) {
            closeAllLists(e.target);
        });

        // Function to update charts and event dropdown after swimmer selection
        function updateChartsAndEventsForSwimmer(swimmerId) {
            currentSelectedSwimmerId = swimmerId; 
            updateSpecialtyChart(swimmerId);
            populateEventSelectForProgression(swimmerId);
        }

        // Event Listeners
        selectEventForProgression.addEventListener('change', (event) => {
            const selectedEvent = event.target.value;
            updateProgressionChart(currentSelectedSwimmerId, selectedEvent);
        });

        // Initial load for dashboard
        document.addEventListener('DOMContentLoaded', loadAllAthleteDataForDashboard);
    </script>
</body>
</html>

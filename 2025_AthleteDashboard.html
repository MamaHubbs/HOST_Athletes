<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Swimmer Performance Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="module">
    import {
      timeToSeconds,
      secondsToTime,
      formatDate,
      formatMMDDYYYY,
      weeklyFileNames
    } from './dashboard-utils.js';

    window.timeToSeconds = timeToSeconds;
    window.secondsToTime = secondsToTime;
    window.formatDate = formatDate;
    window.formatMMDDYYYY = formatMMDDYYYY;
    window.weeklyFileNames = weeklyFileNames;
  </script>
  <style>
    /* original styles here (unchanged) */
  </style>
</head>
<body>
  <div class="container">
    <h1>Swimmer Performance Dashboard</h1>
    <p class="dashboard-intro-text">
      Please select a swimmer to view their overall swim specialty. You can then use the progression chart to track their performance over time for a specific stroke or event.
    </p>

    <div class="filter-section">
      <div class="filter-box autocomplete-container">
        <label for="filterSwimmerName">Search Swimmer:</label>
        <input type="text" id="filterSwimmerName" placeholder="Start typing name..." />
        <div id="swimmerSearchResults" class="autocomplete-items"></div>
      </div>
    </div>

    <div class="chart-section">
      <div class="chart-display">
        <div class="chart-canvas-container specialty-chart-container">
          <h3>Swimmer Specialty (Radar Chart)</h3>
          <canvas id="specialtyChart"></canvas>
        </div>

        <div class="chart-canvas-container progression-chart-container">
          <h3>Time Progression (Line Chart)</h3>
          <div class="chart-controls-inner">
            <div class="dropdown-box">
              <label for="selectEventForProgression">Select Event:</label>
              <select id="selectEventForProgression" disabled>
                <option value="">-- Select an Event --</option>
              </select>
            </div>
          </div>
          <canvas id="progressionChart"></canvas>
        </div>
      </div>
    </div>
  </div>

  <script>
    let allAthleteData = [];
    let uniqueSwimmersData = [];
    let currentSelectedSwimmerId = null;
    let allUniqueMeets = [];
    let maxObservedTimesPerStroke = {};
    let specialtyChartInstance = null;
    let progressionChartInstance = null;

    const filterSwimmerNameInput = document.getElementById('filterSwimmerName');
    const swimmerSearchResultsDiv = document.getElementById('swimmerSearchResults');
    const selectEventForProgression = document.getElementById('selectEventForProgression');

    function transformRawData(rawValues, fieldNames) {
      const transformed = [];
      const lastNameIndex = fieldNames.indexOf('last_name');
      const firstNameIndex = fieldNames.indexOf('first_name');
      const genderIndex = fieldNames.indexOf('competition_category');
      const ageIndex = fieldNames.indexOf('age');
      const meetDateIndex = fieldNames.indexOf('meet_date');
      const meetNameIndex = fieldNames.indexOf('meet_name');
      const eventSwumIndex = fieldNames.indexOf('event_swum');
      const seedTimeIndex = fieldNames.indexOf('seed_time');
      const resultTimeIndex = fieldNames.indexOf('result_time');
      const placeIndex = fieldNames.indexOf('place');
      const pointsIndex = fieldNames.indexOf('points');

      rawValues.forEach((row) => {
        const athleteId = `${row[lastNameIndex]}-${row[firstNameIndex]}`.toLowerCase();
        transformed.push({
          id: athleteId,
          lastName: row[lastNameIndex],
          firstName: row[firstNameIndex],
          category: row[genderIndex],
          age: row[ageIndex],
          meetDate: row[meetDateIndex],
          meetName: String(row[meetNameIndex]).replace('2025 ', ''),
          eventSwum: row[eventSwumIndex],
          seedTime: String(row[seedTimeIndex]),
          resultTime: String(row[resultTimeIndex]),
          place: row[placeIndex],
          points: row[pointsIndex]
        });
      });
      return transformed;
    }

    async function loadAllAthleteDataForDashboard() {
      const allFetchedRawDataPromises = weeklyFileNames.map(async (name) => {
        const filePath = new URL(name, window.location.href).toString();
        try {
          const response = await fetch(filePath);
          if (!response.ok) return [];
          const rawWeekData = await response.json();
          if (rawWeekData && rawWeekData.values && rawWeekData.fields) {
            return transformRawData(rawWeekData.values, rawWeekData.fields);
          }
          return [];
        } catch (error) {
          console.error(`Error fetching ${filePath}:`, error);
          return [];
        }
      });

      const allWeeksTransformedData = await Promise.all(allFetchedRawDataPromises);
      allAthleteData = allWeeksTransformedData.flat();

      const swimmerMap = new Map();
      allAthleteData.forEach((athlete) => {
        const key = `${athlete.lastName}-${athlete.firstName}`.toLowerCase();
        if (!swimmerMap.has(key)) {
          swimmerMap.set(key, {
            id: key,
            firstName: athlete.firstName,
            lastName: athlete.lastName,
            age: athlete.age
          });
        }
      });
      uniqueSwimmersData = Array.from(swimmerMap.values());

      const meetMap = new Map();
      allAthleteData.forEach((data) => {
        const meetKey = `${data.meetDate}-${data.meetName}`;
        if (!meetMap.has(meetKey)) {
          meetMap.set(meetKey, {
            date: data.meetDate,
            name: data.meetName,
            display: `${formatMMDDYYYY(data.meetDate)} (${data.meetName})`
          });
        }
      });
      allUniqueMeets = Array.from(meetMap.values()).sort((a, b) => new Date(a.date) - new Date(b.date));

      const strokes = ['Freestyle', 'Backstroke', 'Breaststroke', 'Butterfly', 'IM'];
      const allStrokeTimes = { Freestyle: [], Backstroke: [], Breaststroke: [], Butterfly: [], IM: [] };

      allAthleteData.forEach((data) => {
        strokes.forEach((stroke) => {
          if (
            data.eventSwum.toLowerCase().includes(stroke.toLowerCase()) &&
            !['NT', 'NS', 'DQ'].includes(data.resultTime)
          ) {
            allStrokeTimes[stroke].push(timeToSeconds(data.resultTime));
          }
        });
      });

      strokes.forEach((stroke) => {
        if (allStrokeTimes[stroke].length > 0) {
          maxObservedTimesPerStroke[stroke] = Math.max(...allStrokeTimes[stroke]) * 1.1;
        } else {
          maxObservedTimesPerStroke[stroke] = 120;
        }
      });

      updateSpecialtyChart(null);
      updateProgressionChart(null, null);
    }

    function updateSpecialtyChart(swimmerId) {
      const chartData = getSpecialtyChartData(swimmerId);
      const ctx = document.getElementById('specialtyChart').getContext('2d');
      const scoreOffset = 50;

      if (specialtyChartInstance) {
        specialtyChartInstance.data = chartData;
        specialtyChartInstance.update();
      } else {
        specialtyChartInstance = new Chart(ctx, {
          type: 'radar',
          data: chartData,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              r: {
                min: 0,
                max: 150,
                ticks: { display: false },
                pointLabels: { font: { size: 10, weight: 'bold' }, color: '#4a5568' }
              }
            },
            plugins: {
              legend: {
                display: true,
                position: 'top',
                labels: { color: '#4a5568', font: { size: 10 } }
              },
              tooltip: {
                callbacks: {
                  label: (ctx) => `${ctx.dataset.label}: ${(ctx.raw - scoreOffset).toFixed(1)}`
                }
              }
            }
          }
        });
      }
    }

    function getSpecialtyChartData(swimmerId) {
      const strokes = ['Freestyle', 'Backstroke', 'Breaststroke', 'Butterfly', 'IM'];
      const specialtyScores = {};
      const scoreOffset = 50;
      const swimmerData = allAthleteData.filter((d) => d.id === swimmerId);

      strokes.forEach((stroke) => {
        const relevantEvents = swimmerData.filter(
          (d) => d.eventSwum.toLowerCase().includes(stroke.toLowerCase()) && !['NT', 'NS', 'DQ'].includes(d.resultTime)
        );
        if (relevantEvents.length > 0) {
          const sumTimes = relevantEvents.reduce((sum, d) => sum + timeToSeconds(d.resultTime), 0);
          const avgTime = sumTimes / relevantEvents.length;
          const maxExpected = maxObservedTimesPerStroke[stroke] || 120;
          let norm = (maxExpected - avgTime) / maxExpected;
          norm = Math.max(0, Math.min(1, norm));
          let finalScore = Math.pow(norm, 2.0) * 100;
          finalScore = Math.max(0, Math.min(100, finalScore));
          specialtyScores[stroke] = finalScore;
        } else {
          specialtyScores[stroke] = 0;
        }
      });

      const swimmerInfo = uniqueSwimmersData.find((s) => s.id === swimmerId);
      const swimmerDisplayName = swimmerInfo ? `${swimmerInfo.lastName}, ${swimmerInfo.firstName}` : 'Selected Swimmer';

      return {
        labels: strokes,
        datasets: [
          {
            label: `${swimmerDisplayName}'s Specialty`,
            data: strokes.map((s) => specialtyScores[s] + scoreOffset),
            backgroundColor: 'rgba(255, 204, 0, 0.4)',
            borderColor: 'rgba(255, 204, 0, 1)',
            pointBackgroundColor: 'rgba(255, 204, 0, 1)',
            borderWidth: 1
          }
        ]
      };
    }

    function updateProgressionChart(swimmerId, selectedEvent) {
      const chartData = getProgressionChartData(swimmerId, selectedEvent);
      const ctx = document.getElementById('progressionChart').getContext('2d');

      if (progressionChartInstance) {
        progressionChartInstance.data = chartData;
        progressionChartInstance.update();
      } else {
        progressionChartInstance = new Chart(ctx, {
          type: 'line',
          data: chartData,
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              x: {
                title: { display: true, text: 'Meet Date (Meet Name)' },
                ticks: { font: { size: 9 } }
              },
              y: {
                reverse: true,
                ticks: {
                  callback: (value) => secondsToTime(value),
                  font: { size: 9 }
                }
              }
            },
            plugins: {
              legend: { display: true },
              tooltip: { enabled: true }
            }
          }
        });
      }
    }

    function getProgressionChartData(swimmerId, eventSwum) {
      const labels = allUniqueMeets.map((m) => m.display);
      const dataPoints = Array(allUniqueMeets.length).fill(null);

      if (!swimmerId || !eventSwum) {
        return {
          labels,
          datasets: [
            {
              label: 'No Event Selected',
              data: dataPoints,
              fill: false,
              borderColor: 'rgba(150, 150, 150, 1)',
              tension: 0.1,
              pointBackgroundColor: 'rgba(150, 150, 150, 1)'
            }
          ]
        };
      }

      const swimmerEventData = allAthleteData
        .filter((d) => d.id === swimmerId && d.eventSwum === eventSwum && !['NT', 'NS', 'DQ'].includes(d.resultTime))
        .sort((a, b) => new Date(a.meetDate) - new Date(b.meetDate));

      swimmerEventData.forEach((entry) => {
        const entryMeetKey = `${entry.meetDate}-${entry.meetName}`;
        const meetIndex = allUniqueMeets.findIndex((meet) => `${meet.date}-${meet.name}` === entryMeetKey);
        if (meetIndex !== -1) {
          dataPoints[meetIndex] = timeToSeconds(entry.resultTime);
        }
      });

      return {
        labels,
        datasets: [
          {
            label: eventSwum,
            data: dataPoints,
            fill: false,
            borderColor: '#4169E1',
            tension: 0.4,
            pointBackgroundColor: '#4169E1',
            spanGaps: true
          }
        ]
      };
    }

    function populateEventSelectForProgression(swimmerId) {
      selectEventForProgression.innerHTML = '<option value="">-- Select an Event --</option>';
      selectEventForProgression.disabled = true;

      if (!swimmerId) return;

      const events = [...new Set(allAthleteData.filter((d) => d.id === swimmerId).map((d) => d.eventSwum))];
      if (events.length > 0) {
        events.sort().forEach((event) => {
          const option = document.createElement('option');
          option.value = event;
          option.textContent = event;
          selectEventForProgression.appendChild(option);
        });
        selectEventForProgression.disabled = false;
      }
    }

    filterSwimmerNameInput.addEventListener('input', function () {
      const inputVal = this.value.toLowerCase();
      closeAllLists();
      if (!inputVal) return;
      const matches = uniqueSwimmersData.filter((s) =>
        `${s.firstName} ${s.lastName}`.toLowerCase().includes(inputVal)
      );
      matches.forEach((swimmer) => {
        const itemDiv = document.createElement('div');
        itemDiv.innerHTML = `<strong>${swimmer.lastName}</strong>, ${swimmer.firstName}`;
        itemDiv.innerHTML += `<input type='hidden' value='${swimmer.id}'>`;
        itemDiv.addEventListener('click', function () {
          filterSwimmerNameInput.value = `${swimmer.lastName}, ${swimmer.firstName}`;
          currentSelectedSwimmerId = swimmer.id;
          updateSpecialtyChart(currentSelectedSwimmerId);
          populateEventSelectForProgression(currentSelectedSwimmerId);
          closeAllLists();
        });
        swimmerSearchResultsDiv.appendChild(itemDiv);
      });
    });

    selectEventForProgression.addEventListener('change', (event) => {
      updateProgressionChart(currentSelectedSwimmerId, event.target.value);
    });

    function closeAllLists(elmnt) {
      const items = document.getElementsByClassName('autocomplete-items');
      for (let i = 0; i < items.length; i++) {
        if (elmnt != items[i] && elmnt != filterSwimmerNameInput) {
          items[i].innerHTML = '';
        }
      }
    }

    document.addEventListener('click', function (e) {
      closeAllLists(e.target);
    });

    document.addEventListener('DOMContentLoaded', loadAllAthleteDataForDashboard);
  </script>
</body>
</html>

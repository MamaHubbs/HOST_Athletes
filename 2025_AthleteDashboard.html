<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Swimmer Performance Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f3f4f6;
    }

    @media print {
      .no-print { display: none !important; }
      body { background: white !important; margin: 0.5cm; font-size: 0.75rem; }
      canvas { display: block !important; page-break-inside: avoid; }
    }
  </style>
</head>
<body class="text-gray-800 p-6 sm:p-10 min-h-screen">
  <div class="max-w-7xl mx-auto bg-white p-6 sm:p-8 rounded-xl shadow-lg">
    <h1 class="text-3xl sm:text-4xl font-extrabold text-center mb-8">Swimmer Performance Dashboard</h1>

    <!-- FILTER CONTROLS -->
    <div class="no-print grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-8">
      <div>
        <label for="selectSwimmer" class="block text-sm font-medium text-gray-700 mb-1">Select Swimmer:</label>
        <select id="selectSwimmer" class="w-full p-2 border border-gray-300 rounded-md">
          <option value="">-- Choose --</option>
        </select>
      </div>
      <div>
        <label for="selectEvent" class="block text-sm font-medium text-gray-700 mb-1">Select Event:</label>
        <select id="selectEvent" class="w-full p-2 border border-gray-300 rounded-md" disabled>
          <option value="">-- Choose --</option>
        </select>
      </div>
      <div>
        <label for="strokeFilter" class="block text-sm font-medium text-gray-700 mb-1">Stroke Filter:</label>
        <select id="strokeFilter" class="w-full p-2 border border-gray-300 rounded-md">
          <option value="">All</option>
          <option value="Freestyle">Freestyle</option>
          <option value="Backstroke">Backstroke</option>
          <option value="Breaststroke">Breaststroke</option>
          <option value="Butterfly">Butterfly</option>
          <option value="IM">IM</option>
        </select>
      </div>
      <div>
        <label for="seasonFilter" class="block text-sm font-medium text-gray-700 mb-1">Season Filter:</label>
        <select id="seasonFilter" class="w-full p-2 border border-gray-300 rounded-md">
          <option value="">All Seasons</option>
        </select>
      </div>
      <div>
        <label for="meetScopeToggle" class="block text-sm font-medium text-gray-700 mb-1">Show Meets:</label>
        <select id="meetScopeToggle" class="w-full p-2 border border-gray-300 rounded-md">
          <option value="has-times">Only With Times</option>
          <option value="all">All Meets</option>
        </select>
      </div>
    </div>

    <!-- CHART DISPLAY -->
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <div class="bg-purple-50 p-4 rounded-lg shadow">
        <h2 class="text-lg font-bold mb-3 text-center">Specialty (Radar Chart)</h2>
        <canvas id="specialtyChart" height="300"></canvas>
      </div>
      <div class="bg-purple-50 p-4 rounded-lg shadow">
        <h2 class="text-lg font-bold mb-3 text-center">Time Progression (Line Chart)</h2>
        <canvas id="progressionChart" height="300"></canvas>
      </div>
    </div>

    <script>
// === Chart Helper Functions ===
function timeToSeconds(timeStr) {
  if (!timeStr || timeStr === 'NT' || timeStr === 'NS' || timeStr === 'DQ') return Infinity;
  const parts = String(timeStr).split(':');
  return parts.length === 2
    ? parseInt(parts[0]) * 60 + parseFloat(parts[1])
    : parseFloat(parts[0]);
}

function secondsToTime(sec) {
  if (!isFinite(sec)) return 'N/A';
  const min = Math.floor(sec / 60);
  const rem = (sec % 60).toFixed(2).padStart(5, '0');
  return `${min}:${rem}`;
}

// === State ===
let allAthleteData = [];
let specialtyChart = null;
let progressionChart = null;

const selectSwimmer = document.getElementById('selectSwimmer');
const selectEvent = document.getElementById('selectEvent');
const selectStroke = document.getElementById('strokeFilter');
const selectSeason = document.getElementById('seasonFilter');
const toggleMeetScope = document.getElementById('meetScopeToggle');

// === Chart Setup ===
function updateSpecialtyChart(swimmerId) {
  const swimmerData = allAthleteData.filter(d => d.id === swimmerId);
  const strokes = ['Freestyle', 'Backstroke', 'Breaststroke', 'Butterfly', 'IM'];
  const scores = strokes.map(stroke => {
    const events = swimmerData.filter(d => d.eventSwum.toLowerCase().includes(stroke.toLowerCase()) && isFinite(timeToSeconds(d.resultTime)));
    const avg = events.length ? events.reduce((a, b) => a + timeToSeconds(b.resultTime), 0) / events.length : Infinity;
    return avg === Infinity ? 0 : Math.max(0, (120 - avg) / 120 * 100);
  });
  const ctx = document.getElementById('specialtyChart').getContext('2d');
  if (specialtyChart) specialtyChart.destroy();
  specialtyChart = new Chart(ctx, {
    type: 'radar',
    data: { labels: strokes, datasets: [{ label: 'Specialty', data: scores }] },
    options: { scales: { r: { min: 0, max: 100 } } }
  });
}

function updateProgressionChart(swimmerId, eventLabel) {
  const swimmerData = allAthleteData.filter(d => d.id === swimmerId);
  const dataPoints = swimmerData.filter(d => normalizeEventName(d.eventSwum) === eventLabel && isFinite(timeToSeconds(d.resultTime)))
    .sort((a, b) => new Date(a.meetDate) - new Date(b.meetDate));
  const times = dataPoints.map(d => timeToSeconds(d.resultTime));
  const labels = dataPoints.map(d => new Date(d.meetDate).toLocaleDateString());
  const ctx = document.getElementById('progressionChart').getContext('2d');
  if (progressionChart) progressionChart.destroy();
  progressionChart = new Chart(ctx, {
    type: 'line',
    data: { labels, datasets: [{ label: eventLabel, data: times, fill: false, borderColor: 'teal', tension: 0.2 }] },
    options: {
      scales: {
        y: {
          reverse: true,
          ticks: {
            callback: val => secondsToTime(val)
          }
        }
      }
    }
  });
}

// === Helpers ===
function normalizeEventName(name) {
  return name.replace(/\d{2}-\d{2}\s*/g, '').trim();
}
function populateFilters() {
  const swimmerMap = new Map();
  const eventSet = new Set();
  const strokeSet = new Set();
  const seasonSet = new Set();

  allAthleteData.forEach(row => {
    const id = `${row.lastName}-${row.firstName}`.toLowerCase();
    swimmerMap.set(id, `${row.firstName} ${row.lastName}`);
    eventSet.add(normalizeEventName(row.eventSwum));
    if (row.eventSwum) strokeSet.add(row.eventSwum.match(/Freestyle|Backstroke|Breaststroke|Butterfly|IM/i)?.[0]);
    if (row.meetDate) seasonSet.add(new Date(row.meetDate).getFullYear());
  });

  [selectSwimmer, selectEvent, selectStroke, selectSeason].forEach(sel => sel.innerHTML = '<option value="">All</option>');

  [...swimmerMap.entries()].sort().forEach(([id, name]) => {
    const opt = document.createElement('option'); opt.value = id; opt.textContent = name;
    selectSwimmer.appendChild(opt);
  });
  [...eventSet].sort().forEach(e => {
    const opt = document.createElement('option'); opt.value = e; opt.textContent = e;
    selectEvent.appendChild(opt);
  });
  [...strokeSet].sort().forEach(s => {
    const opt = document.createElement('option'); opt.value = s; opt.textContent = s;
    selectStroke.appendChild(opt);
  });
  [...seasonSet].sort().forEach(s => {
    const opt = document.createElement('option'); opt.value = s; opt.textContent = s;
    selectSeason.appendChild(opt);
  });
}

// === Event Binding ===
function handleFilters() {
  const swimmerId = selectSwimmer.value;
  const eventLabel = selectEvent.value;
  const stroke = selectStroke.value;
  const season = selectSeason.value;
  const meetScope = toggleMeetScope.value;

  let swimmerData = allAthleteData;

  if (stroke) {
    swimmerData = swimmerData.filter(d => d.eventSwum.toLowerCase().includes(stroke.toLowerCase()));
  }

  if (season) {
    swimmerData = swimmerData.filter(d => new Date(d.meetDate).getFullYear().toString() === season);
  }

  if (swimmerId) {
    updateSpecialtyChart(swimmerId);
  }

  if (swimmerId && eventLabel) {
    updateProgressionChart(swimmerId, eventLabel);
  }

  // Save preferences
  localStorage.setItem('selectedSwimmer', swimmerId);
  localStorage.setItem('selectedEvent', eventLabel);
  localStorage.setItem('selectedStroke', stroke);
  localStorage.setItem('selectedSeason', season);
  localStorage.setItem('toggleMeetScope', meetScope);
}

[selectSwimmer, selectEvent, selectStroke, selectSeason, toggleMeetScope].forEach(el => {
  el.addEventListener('change', handleFilters);
});

// === Load and Init ===
async function fetchData() {
  try {
    const res = await fetch('2025resultsweek01.json');
    const json = await res.json();
    const f = json.fields;
    allAthleteData = json.values.map(row => ({
      id: `${row[f.indexOf('last_name')]}-${row[f.indexOf('first_name')]}`.toLowerCase(),
      firstName: row[f.indexOf('first_name')],
      lastName: row[f.indexOf('last_name')],
      eventSwum: row[f.indexOf('event_swum')],
      resultTime: String(row[f.indexOf('result_time')]),
      meetDate: row[f.indexOf('meet_date')]
    }));
    populateFilters();

    // Restore saved state
    selectSwimmer.value = localStorage.getItem('selectedSwimmer') || '';
    selectEvent.value = localStorage.getItem('selectedEvent') || '';
    selectStroke.value = localStorage.getItem('selectedStroke') || '';
    selectSeason.value = localStorage.getItem('selectedSeason') || '';
    toggleMeetScope.checked = localStorage.getItem('toggleMeetScope') === 'true';
    handleFilters();
  } catch (err) {
    console.error('Error loading data:', err);
  }
}

window.addEventListener('DOMContentLoaded', fetchData);
</script>


    
</body>
</html>

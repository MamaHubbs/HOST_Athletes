<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Swimmer Performance Dashboard</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script type="module" src="dashboard-utils.js"></script>
  <style>
    body {
      font-family: 'Inter', sans-serif;
      background-color: #f3f4f6;
    }
    @media print {
      .no-print { display: none !important; }
      body { background: white !important; margin: 0.5cm; font-size: 0.75rem; }
      canvas { display: block !important; page-break-inside: avoid; }
    }
  </style>
</head>
<body class="text-gray-800 p-6 sm:p-10 min-h-screen">
  <div class="max-w-7xl mx-auto bg-white p-6 sm:p-8 rounded-xl shadow-lg">
    <h1 class="text-3xl sm:text-4xl font-extrabold text-center mb-8">Swimmer Performance Dashboard</h1>
    <div class="no-print grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-8">
      <div>
        <label for="selectSwimmer" class="block text-sm font-medium text-gray-700 mb-1">Select Swimmer:</label>
        <select id="selectSwimmer" class="w-full p-2 border border-gray-300 rounded-md">
          <option value="">-- Choose --</option>
        </select>
      </div>
      <div>
        <label for="selectEvent" class="block text-sm font-medium text-gray-700 mb-1">Select Event:</label>
        <select id="selectEvent" class="w-full p-2 border border-gray-300 rounded-md" disabled>
          <option value="">-- Choose --</option>
        </select>
      </div>
      <div>
        <label for="strokeFilter" class="block text-sm font-medium text-gray-700 mb-1">Stroke Filter:</label>
        <select id="strokeFilter" class="w-full p-2 border border-gray-300 rounded-md">
          <option value="">All</option>
          <option value="Freestyle">Freestyle</option>
          <option value="Backstroke">Backstroke</option>
          <option value="Breaststroke">Breaststroke</option>
          <option value="Butterfly">Butterfly</option>
          <option value="IM">IM</option>
        </select>
      </div>
      <div>
        <label for="seasonFilter" class="block text-sm font-medium text-gray-700 mb-1">Season Filter:</label>
        <select id="seasonFilter" class="w-full p-2 border border-gray-300 rounded-md">
          <option value="">All Seasons</option>
        </select>
      </div>
      <div>
        <label for="meetScopeToggle" class="block text-sm font-medium text-gray-700 mb-1">Show Meets:</label>
        <select id="meetScopeToggle" class="w-full p-2 border border-gray-300 rounded-md">
          <option value="has-times">Only With Times</option>
          <option value="all">All Meets</option>
        </select>
      </div>
    </div>
    <div class="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <div class="bg-purple-50 p-4 rounded-lg shadow">
        <h2 class="text-lg font-bold mb-3 text-center">Specialty (Radar Chart)</h2>
        <canvas id="specialtyChart" height="300"></canvas>
      </div>
      <div class="bg-purple-50 p-4 rounded-lg shadow">
        <h2 class="text-lg font-bold mb-3 text-center">Time Progression (Line Chart)</h2>
        <canvas id="progressionChart" height="300"></canvas>
      </div>
    </div>

 <script type="module">
      import { timeToSeconds, secondsToTime, formatDate, formatMMDDYYYY, weeklyFileNames } from './dashboard-utils.js';

      let allAthleteData = [];
      let specialtyChart = null;
      let progressionChart = null;

      const selectSwimmer = document.getElementById('selectSwimmer');
      const selectEvent = document.getElementById('selectEvent');
      const selectStroke = document.getElementById('strokeFilter');
      const selectSeason = document.getElementById('seasonFilter');
      const toggleMeetScope = document.getElementById('meetScopeToggle');

function normalizeEventName(name) {
  return name.replace(/\d{2}-\d{2}\s*/, '').trim();
}

      function updateSpecialtyChart(swimmerId) {
        const swimmerData = allAthleteData.filter(d => d.id === swimmerId);
        const strokes = ['Freestyle', 'Backstroke', 'Breaststroke', 'Butterfly', 'IM'];
        const scores = strokes.map(stroke => {
          const events = swimmerData.filter(d => d.eventSwum.toLowerCase().includes(stroke.toLowerCase()) && isFinite(timeToSeconds(d.resultTime)));
          const avg = events.length ? events.reduce((a, b) => a + timeToSeconds(b.resultTime), 0) / events.length : Infinity;
          return avg === Infinity ? 0 : Math.max(0, (120 - avg) / 120 * 100);
        });
        const ctx = document.getElementById('specialtyChart').getContext('2d');
        if (specialtyChart) specialtyChart.destroy();
        specialtyChart = new Chart(ctx, {
          type: 'radar',
          data: { labels: strokes, datasets: [{ label: 'Specialty', data: scores }] },
          options: { scales: { r: { min: 0, max: 100 } } }
        });
      }

      function updateProgressionChart(swimmerId, eventLabel) {
        const swimmerData = allAthleteData.filter(d => d.id === swimmerId);
        const allDates = [...new Set(swimmerData.map(d => d.meetDate))].sort((a, b) => new Date(a) - new Date(b));
        const timesByDate = {};
        const normEventLabel = normalizeEventName(eventLabel);
swimmerData.filter(d => normalizeEventName(d.eventSwum) === normEventLabel && isFinite(timeToSeconds(d.resultTime)))
          .forEach(d => {
            timesByDate[d.meetDate] = timeToSeconds(d.resultTime);
          });

        const labels = allDates.map(d => formatMMDDYYYY(d));
        const data = allDates.map(d => timesByDate[d] !== undefined ? timesByDate[d] : null);

        const ctx = document.getElementById('progressionChart').getContext('2d');
        if (progressionChart) progressionChart.destroy();
        progressionChart = new Chart(ctx, {
          type: 'line',
          data: {
            labels,
            datasets: [{ label: eventLabel, data, fill: false, borderColor: 'teal', tension: 0.2 }]
          },
          options: {
            spanGaps: false,
            scales: {
              y: {
                reverse: true,
                ticks: {
                  callback: val => secondsToTime(val)
                }
              }
            }
          }
        });
      }

      function populateFilters() {
        const swimmerMap = new Map();
        const eventSet = new Set();
        const strokeSet = new Set();
        const seasonSet = new Set();
        selectEvent.disabled = false;

        allAthleteData.forEach(row => {
          const id = `${row.lastName}-${row.firstName}`.toLowerCase();
          swimmerMap.set(id, `${row.firstName} ${row.lastName}`);
          eventSet.add(normalizeEventName(row.eventSwum));
          if (row.eventSwum) strokeSet.add(row.eventSwum.match(/Freestyle|Backstroke|Breaststroke|Butterfly|IM/i)?.[0]);
          if (row.meetDate) seasonSet.add(new Date(row.meetDate).getFullYear());
        });

        [selectSwimmer, selectEvent, selectStroke, selectSeason].forEach(sel => sel.innerHTML = '<option value="">All</option>');

        [...swimmerMap.entries()].sort().forEach(([id, name]) => {
          const opt = document.createElement('option'); opt.value = id; opt.textContent = name;
          selectSwimmer.appendChild(opt);
        });
const seen = new Set();
[...eventSet].sort().forEach(e => {
  if (!seen.has(e)) {
    const opt = document.createElement('option');
    opt.value = e;
    opt.textContent = e;
    selectEvent.appendChild(opt);
    seen.add(e);
  }
});
        [...strokeSet].sort().forEach(s => {
          const opt = document.createElement('option'); opt.value = s; opt.textContent = s;
          selectStroke.appendChild(opt);
        });
        [...seasonSet].sort().forEach(s => {
          const opt = document.createElement('option'); opt.value = s; opt.textContent = s;
          selectSeason.appendChild(opt);
        });
      }

      function handleFilters() {
const swimmerId = selectSwimmer.value;
const swimmerData = allAthleteData.filter(d => d.id === swimmerId);
        const eventLabel = selectEvent.value;
        if (swimmerId) updateSpecialtyChart(swimmerId);
        if (swimmerId && eventLabel) updateProgressionChart(swimmerId, eventLabel);
      }

// Clear and repopulate event and stroke dropdowns
selectEvent.innerHTML = '<option value="">All</option>';
selectStroke.innerHTML = '<option value="">All</option>';

const localEventSet = new Set();
const localStrokeSet = new Set();

swimmerData.forEach(row => {
  localEventSet.add(normalizeEventName(row.eventSwum));
  const stroke = row.eventSwum.match(/Freestyle|Backstroke|Breaststroke|Butterfly|IM/i)?.[0];
  if (stroke) localStrokeSet.add(stroke);
});

[...localEventSet].sort().forEach(e => {
  const opt = document.createElement('option'); opt.value = e; opt.textContent = e;
  selectEvent.appendChild(opt);
});
[...localStrokeSet].sort().forEach(s => {
  const opt = document.createElement('option'); opt.value = s; opt.textContent = s;
  selectStroke.appendChild(opt);
});

      async function fetchAllData() {
        const allData = await Promise.all(
          weeklyFileNames.map(async path => {
            try {
              const res = await fetch(path);
              const json = await res.json();
              const f = json.fields;
              return json.values.map(row => ({
                id: `${row[f.indexOf('last_name')]}-${row[f.indexOf('first_name')]}`.toLowerCase(),
                firstName: row[f.indexOf('first_name')],
                lastName: row[f.indexOf('last_name')],
                eventSwum: row[f.indexOf('event_swum')],
                resultTime: String(row[f.indexOf('result_time')]),
                meetDate: row[f.indexOf('meet_date')]
              }));
            } catch {
              return [];
            }
          })
        );
        allAthleteData = allData.flat();
        populateFilters();
        handleFilters();
      }

      window.addEventListener('DOMContentLoaded', fetchAllData);
    </script>
  </div>
</body>
</html>

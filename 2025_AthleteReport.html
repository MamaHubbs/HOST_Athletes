function renderTable(data, isSpecificMeetSelected = false, meetCourse = 'mixed') { 
        console.log(`RENDER TABLE DEBUG: isSpecificMeetSelected=${isSpecificMeetSelected}, meetCourse=${meetCourse}`); 
        reportTableBody.innerHTML = '';
        summaryChartTableBody.innerHTML = ''; 
        individualAthleteSummary.style.display = 'none'; 

        const athletesGrouped = data.reduce((acc, current) => {
            // THIS IS THE CRUCIAL LINE FOR GROUPING: EXCLUDES AGE
            const uniqueAthleteGroupId = `${current.lastName}-${current.firstName}-${current.category}`; 
            
            if (!acc[uniqueAthleteGroupId]) {
                acc[uniqueAthleteGroupId] = {
                    id: uniqueAthleteGroupId, // This ID is now LastName-FirstName-Category
                    lastName: current.lastName, 
                    firstName: current.firstName, 
                    category: current.category, 
                    events: []
                };
            }
            acc[uniqueAthleteGroupId].events.push(current);
            return acc;
        }, {});

        const athleteGroups = Object.values(athletesGrouped).sort((a, b) => {
            const lastNameCompare = a.lastName.localeCompare(b.lastName);
            if (lastNameCompare !== 0) {
                return lastNameCompare;
            }
            return a.firstName.localeCompare(b.firstName);
        });

        let colspan = 9; 
        if (isSpecificMeetSelected && meetCourse === 'y') {
            colspan = 10; 
        }

        if (athleteGroups.length === 0) {
            const noResultsRow = document.createElement('tr');
            noResultsRow.innerHTML = `
                <td colspan="${colspan}" class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 text-center">
                    No results found matching your filters.
                </td>
            `;
            reportTableBody.appendChild(noResultsRow);
            return;
        }

        // isSingleAthleteView still checks for only one unique ID, which now means one unique LastName-FirstName-Category
        const isSingleAthleteView = athleteGroups.length === 1 && filterNameInput.value.trim() !== '';
        let singleAthleteDisplayName = '';

        athleteGroups.forEach(athleteGroup => {
            let athleteDisplayName = `${athleteGroup.lastName}, ${athleteGroup.firstName}`;
            // Age is only added to the display name if a specific meet is selected
            if (isSpecificMeetSelected && athleteGroup.events.length > 0) {
                athleteDisplayName += ` (${athleteGroup.events[0].age})`; 
            }
            athleteDisplayName += ` - ${athleteGroup.category}`;

            if (isSingleAthleteView) {
                singleAthleteDisplayName = athleteDisplayName;
            }

            const athleteHeaderRow = document.createElement('tr');
            athleteHeaderRow.className = 'athlete-header-row';
            athleteHeaderRow.innerHTML = `
                <td colspan="${colspan}" style="background-color: #0156B3; color: white; text-align: left !important; font-weight: bold; padding: 6px 10px;">${athleteDisplayName}</td>
            `;
            reportTableBody.appendChild(athleteHeaderRow);

            const eventSubHeaderRow = document.createElement('tr');
            eventSubHeaderRow.className = 'event-subheader-row';

            let headerHtml = `
                <th style="width: 1%;"></th> <th>Meet Date</th>
                <th>Meet Name</th>
                <th>Event</th>
            `;

            if (isSpecificMeetSelected && meetCourse === 'y') {
                headerHtml += `<th>Seed (Yds)</th><th>Final (Yds)</th><th>SCM Time</th>`; 
            } else {
                headerHtml += `<th>Seed (SCM)</th><th>Final (SCM)</th>`; 
            }

            headerHtml += `
                <th>Place</th>
                <th>Points</th>
                <th>% Improvement</th>
            `;
            eventSubHeaderRow.innerHTML = headerHtml;
            reportTableBody.appendChild(eventSubHeaderRow);

            const eventsByEventSwum = athleteGroup.events.reduce((acc, current) => {
                if (!acc[current.eventSwum]) {
                    acc[current.eventSwum] = [];
                }
                acc[current.eventSwum].push(current);
                return acc;
            }, {});

            const sortedEventTypes = Object.keys(eventsByEventSwum).sort();

            sortedEventTypes.forEach(eventSwumType => {
                const eventPerformances = eventsByEventSwum[eventSwumType].sort((a, b) => new Date(a.meetDate) - new Date(b.meetDate));

                eventPerformances.forEach(eventData => {
                    const seedSeconds = timeToSeconds(eventData.seedTimeOriginal); 
                    const resultSeconds = timeToSeconds(eventData.resultTimeOriginal); 

                    let improvement = 'N/A';
                    if (seedSeconds !== Infinity && resultSeconds !== Infinity && seedSeconds > 0) {
                        improvement = (((seedSeconds - resultSeconds) / seedSeconds) * 100).toFixed(2);
                        if (parseFloat(improvement) > 0) {
                            improvement = `+${improvement}%`;
                        } else {
                            improvement = `${improvement}%`;
                        }
                    }

                    let cellsHtml = `
                        <td style="width: 1%;"></td> 
                        <td>${formatMMDDYYYY(eventData.meetDate)}</td>
                        <td>${eventData.meetName}</td>
                        <td>${eventData.eventSwum}</td>
                    `;

                    if (isSpecificMeetSelected && meetCourse === 'y') {
                        cellsHtml += `
                            <td>${eventData.seedTimeOriginal}</td> 
                            <td>${eventData.resultTimeOriginal}</td> 
                            <td>${eventData.resultTimeSCM}</td> 
                        `;
                    } else {
                        let displaySeedSCM = eventData.seedTimeSCM;
                        if (eventData.seedConverted) { 
                            displaySeedSCM += '*';
                        }
                        let displayFinalSCM = eventData.resultTimeSCM;
                        if (eventData.finalConverted) { 
                            displayFinalSCM += '*';
                        }
                        cellsHtml += `
                            <td>${displaySeedSCM}</td> 
                            <td>${displayFinalSCM}</td> 
                        `;
                    }

                    cellsHtml += `
                        <td>${eventData.place}</td>
                        <td>${eventData.points}</td>
                        <td>${improvement}</td>
                    `;
                    const eventRow = document.createElement('tr');
                    eventRow.className = 'event-data-row hover:bg-gray-50';
                    eventRow.innerHTML = cellsHtml;
                    reportTableBody.appendChild(eventRow);
                });

                if (isSingleAthleteView && eventPerformances.length > 1) {
                    const firstPerformance = eventPerformances[0];
                    const lastPerformance = eventPerformances[eventPerformances.length - 1];

                    const firstTime = timeToSeconds(firstPerformance.resultTimeOriginal); 
                    const lastTime = timeToSeconds(lastPerformance.resultTimeOriginal);

                    let overallImprovement = 'N/A';
                    if (firstTime !== Infinity && lastTime !== Infinity && firstTime > 0) {
                        const improvementPercentage = (((firstTime - lastTime) / firstTime) * 100).toFixed(2);
                        if (parseFloat(improvementPercentage) > 0) {
                            overallImprovement = `+${improvementPercentage}%`;
                        } else {
                            overallImprovement = `${improvementPercentage}%`;
                        }
                    }

                    let displayFirstTimeSummary = firstPerformance.resultTimeSCM;
                    if (firstPerformance.finalConverted) {
                        displayFirstTimeSummary += '*';
                    }
                    let displayLastTimeSummary = lastPerformance.resultTimeSCM;
                    if (lastPerformance.finalConverted) {
                        displayLastTimeSummary += '*';
                    }
                    
                    const summaryChartRow = document.createElement('tr');
                    summaryChartRow.innerHTML = `
                        <td>${eventSwumType}</td>
                        <td>${displayFirstTimeSummary}</td>
                        <td>${displayLastTimeSummary}</td>
                        <td>${overallImprovement}</td>
                    `;
                    summaryChartTableBody.appendChild(summaryChartRow);
                }
            });
        });

        if (isSingleAthleteView && summaryChartTableBody.children.length > 0) {
            summaryChartTitle.textContent = `Overall Improvement for ${singleAthleteDisplayName}`;
            individualAthleteSummary.style.display = 'block';
        }
    }

        if (applyFiltersButton) applyFiltersButton.remove(); 

        function applyFilters() { 
            fetchAndRenderData(); 
        }

        function resetFilters() {
            filterNameInput.value = '';
            filterStrokeInput.value = '';
            filterSeasonInput.value = ''; 
            
            populateJsonFileSelector(""); 
            jsonFileSelector.value = ""; 

            fetchAndRenderData(); 
        }

        // Event Listeners
        resetFiltersButton.addEventListener('click', resetFilters);
        printReportButton.addEventListener('click', () => {
            const filtersContainer = document.querySelector('.dropdown-container');
            if (filtersContainer) filtersContainer.style.display = 'none';
            const printButton = document.getElementById('printReport');
            if (printButton) printButton.style.display = 'none';

            window.print();
            
            if (filtersContainer) filtersContainer.style.display = ''; 
            if (printButton) printButton.style.display = ''; 
        });

        filterSeasonInput.addEventListener('change', async (event) => {
            const selectedSeason = event.target.value;
            filterNameInput.value = ''; 
            filterStrokeInput.value = ''; 
            
            await populateJsonFileSelector(selectedSeason); 
            
            if (selectedSeason === '' || selectedSeason === 'all-seasons-explicit') {
                jsonFileSelector.value = "all-results"; 
            } else { 
                jsonFileSelector.value = `all-meets-for-season-${selectedSeason}`; 
            }
            fetchAndRenderData(); 
        });

        jsonFileSelector.addEventListener('change', (event) => {
            fetchAndRenderData(); 
        });
        
        // Autocomplete for filterNameInput
        filterNameInput.addEventListener('input', function() {
            const inputVal = this.value.toLowerCase();
            filterNameSearchResultsDiv.innerHTML = ''; 
            
            delete this.dataset.selectedId; 
            
            if (!inputVal) {
                applyFilters(); 
                return;
            }

            const matches = uniqueSwimmersForAutocomplete.filter(swimmer => 
                swimmer.displayName.toLowerCase().includes(inputVal) ||
                `${swimmer.firstName} ${swimmer.lastName}`.toLowerCase().includes(inputVal) ||
                `${swimmer.lastName} ${swimmer.firstName}`.toLowerCase().includes(inputVal)
            );

            matches.forEach(swimmer => {
                const itemDiv = document.createElement('div');
                itemDiv.textContent = swimmer.displayName; 
                
                itemDiv.addEventListener('click', function() {
                    filterNameInput.value = swimmer.displayName; 
                    filterNameInput.dataset.selectedId = swimmer.id; 
                    filterNameSearchResultsDiv.innerHTML = ''; 
                    applyFilters(); 
                });
                filterNameSearchResultsDiv.appendChild(itemDiv);
            });
             if (matches.length === 1 && matches[0].displayName.toLowerCase() === inputVal) {
                filterNameInput.value = matches[0].displayName;
                filterNameInput.dataset.selectedId = matches[0].id;
                filterNameSearchResultsDiv.innerHTML = '';
                applyFilters();
            } else if (matches.length > 0) { 
                 applyFilters(); 
            } else { 
                 applyFilters(); 
            }
        });

        // Close autocomplete results when clicking outside, excluding the input and results div itself
        document.addEventListener('click', function(e) {
            if (e.target !== filterNameInput && e.target.parentNode !== filterNameSearchResultsDiv && e.target.closest('#filterNameSearchResults') === null) {
                filterNameSearchResultsDiv.innerHTML = '';
            }
        });


        filterStrokeInput.addEventListener('change', (event) => {
            applyFilters(); 
        });


        document.addEventListener('DOMContentLoaded', async () => {
            await fetchAllFileMetadata(); 
            await populateSeasonFilter(); 
            
            if (allAthleteData.length === 0) {
                 const allFetchedRawDataPromises = weeklyFileNames.map(async (name) => {
                    const filePath = new URL(name, window.location.href).toString();
                    try {
                        const response = await fetch(filePath);
                        if (!response.ok) {
                            console.warn(`Could not fetch ${filePath}. Skipping data load.`);
                            return [];
                        }
                        const rawWeekData = await response.json();
                        if (rawWeekData && rawWeekData.values && rawWeekData.fields) {
                            return transformRawData(rawWeekData.values, rawWeekData.fields);
                        }
                        return [];
                    } catch (error) {
                        console.error(`Error fetching ${filePath}:`, error);
                        return [];
                    }
                });
                allAthleteData = (await Promise.all(allFetchedRawDataPromises)).flat();
                console.log("Initial allAthleteData load on DOMContentLoaded:", allAthleteData.length, "records.");
                populateUniqueSwimmersForAutocomplete(); 
            }

            filterSeasonInput.value = ""; 
            filterNameInput.value = ""; 
            filterStrokeInput.value = ""; 
            
            await populateJsonFileSelector(filterSeasonInput.value); 
            jsonFileSelector.value = ""; 

            fetchAndRenderData(); 
        });
    </script>
</body>
</html>

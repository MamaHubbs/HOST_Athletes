<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Athlete Meet Summary Dashboard</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Chart.js CDN -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        /* Set default font to Inter */
        body {
            font-family: 'Inter', sans-serif;
        }

        /* Basic table styling for better readability */
        table {
            width: 100%;
            border-collapse: collapse;
            margin-top: 20px;
        }

        th, td {
            padding: 12px 15px;
            text-align: left;
            /* Applying border only to bottom for data rows, full border for headers */
            border-bottom: 1px solid #e2e8f0; /* Tailwind's gray-200 */
        }

        /* Specific styling for the new athlete header rows */
        .athlete-header-row {
            background-color: #e0e7ff; /* Light blue-200 */
            font-weight: bold;
            font-size: 1.1em;
            color: #1f2937; /* Gray-800 */
            border-top: 2px solid #6366f1; /* Indigo-500 */
            border-bottom: 2px solid #6366f1; /* Indigo-500 */
            text-align: left !important;
        }

        /* Specific styling for the event sub-header rows */
        .event-subheader-row th {
            background-color: #f8fafc; /* Tailwind's gray-50 */
            font-weight: 600;
            color: #4a5568; /* Tailwind's gray-700 */
            padding-left: 30px; /* Indent the sub-headers */
            border-bottom: 1px solid #cbd5e0; /* Gray-300 */
        }

        /* Styling for the data rows under events */
        .event-data-row td {
            padding-left: 40px; /* Indent the event data */
        }

        tr:hover {
            background-color: #f0f4f8; /* Lighter hover effect */
        }

        /* Custom styles for printing */
        @media print {
            body {
                -webkit-print-color-adjust: exact !important;
                print-color-adjust: exact !important;
            }
            .no-print {
                display: none !important;
            }
            /* Ensure table borders are visible for print */
            table, th, td {
                border-collapse: collapse;
                border: 1px solid #ddd; /* Light gray border */
            }
            /* Override background for printing */
            .bg-gray-100 {
                background-color: #ffffff !important;
            }
            .text-gray-800 {
                color: #000000 !important;
            }
            /* Hide charts on print for cleaner table output, unless explicitly needed */
            .chart-section {
                display: none !important;
            }
            /* Adjust padding for print to avoid cutting off text */
            table th, table td {
                padding: 4px 6px;
                font-size: 0.8em;
            }
            .athlete-header-row {
                background-color: #e0e7ff !important;
                color: #1f2937 !important;
                border-top: 1px solid #6366f1 !important;
                border-bottom: 1px solid #6366f1 !important;
            }
        }
    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-6 sm:p-10 min-h-screen flex flex-col items-center">
    <div class="container mx-auto bg-white p-6 sm:p-8 rounded-xl shadow-lg max-w-7xl w-full">
        <h1 class="text-3xl sm:text-4xl font-extrabold text-gray-900 mb-6 text-center">Athlete Meet Summary Dashboard</h1>

        <!-- Filter Controls - No Print -->
        <div class="no-print mb-6 p-4 bg-blue-50 rounded-lg shadow-inner">
            <h2 class="text-xl font-semibold text-gray-800 mb-4">Report Filters</h2>
            <div class="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4 mb-4">
                <div>
                    <label for="filterName" class="block text-sm font-medium text-gray-700 mb-1">Filter by Name:</label>
                    <input type="text" id="filterName" placeholder="Enter full name or part" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div>
                    <label for="filterCategory" class="block text-sm font-medium text-gray-700 mb-1">Filter by Category:</label>
                    <input type="text" id="filterCategory" placeholder="e.g., Female, Male" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div>
                    <label for="filterEvent" class="block text-sm font-medium text-gray-700 mb-1">Filter by Event:</label>
                    <input type="text" id="filterEvent" placeholder="e.g., Freestyle, Backstroke" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                </div>
            </div>
            <!-- New: JSON File Selector and Date Range Filters -->
            <div class="grid grid-cols-1 md:grid-cols-3 gap-4 mb-4">
                <div>
                    <label for="jsonFileSelector" class="block text-sm font-medium text-gray-700 mb-1">Load Results File:</label>
                    <select id="jsonFileSelector" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                        <!-- Options populated by JavaScript with date ranges -->
                    </select>
                </div>
                <div>
                    <label for="filterStartDate" class="block text-sm font-medium text-gray-700 mb-1">Start Date:</label>
                    <input type="date" id="filterStartDate" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                </div>
                <div>
                    <label for="filterEndDate" class="block text-sm font-medium text-gray-700 mb-1">End Date:</label>
                    <input type="date" id="filterEndDate" class="w-full p-2 border border-gray-300 rounded-md focus:ring-blue-500 focus:border-blue-500">
                </div>
            </div>
            <div class="flex flex-col sm:flex-row gap-4">
                <button id="applyFilters" class="flex-1 bg-blue-600 hover:bg-blue-700 text-white font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                    Apply Filters
                </button>
                <button id="resetFilters" class="flex-1 bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-lg shadow-md transition duration-300 ease-in-out transform hover:scale-105">
                    Reset Filters
                </button>
            </div>
        </div>

        <!-- Dashboard Section -->
        <div class="chart-section mt-8 mb-6 p-4 bg-purple-50 rounded-lg shadow-inner no-print">
            <h2 class="text-xl sm:text-2xl font-bold text-gray-900 mb-4 text-center">Swimmer Performance Dashboard</h2>

            <div class="mb-6">
                <label for="selectSwimmer" class="block text-lg font-medium text-gray-700 mb-2">Select Swimmer for Charts:</label>
                <select id="selectSwimmer" class="w-full p-3 border border-gray-300 rounded-md bg-white focus:ring-purple-500 focus:border-purple-500">
                    <option value="">-- Select an Athlete --</option>
                    <!-- Options will be populated by JavaScript -->
                </select>
            </div>

            <div class="grid grid-cols-1 lg:grid-cols-2 gap-8 mt-6">
                <!-- Specialty Chart -->
                <div class="bg-white p-6 rounded-lg shadow-md flex flex-col items-center">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">Swimmer Specialty (Radar Chart)</h3>
                    <canvas id="specialtyChart" width="400" height="400"></canvas>
                </div>

                <!-- Progression Chart -->
                <div class="bg-white p-6 rounded-lg shadow-md flex flex-col items-center">
                    <h3 class="text-lg font-semibold text-gray-800 mb-4">Time Progression (Line Chart)</h3>
                    <canvas id="progressionChart" width="400" height="400"></canvas>
                </div>
            </div>
        </div>

        <!-- Print Button - No Print -->
        <div class="no-print flex justify-center mb-6">
            <button id="printReport" class="bg-green-600 hover:bg-green-700 text-white font-bold py-3 px-6 rounded-lg shadow-lg transition duration-300 ease-in-out transform hover:scale-105 flex items-center space-x-2">
                <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor" stroke-width="2">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M17 17h2a2 2 0 002-2v-4a2 2 0 00-2-2H5a2 2 0 00-2 2v4a2 2 0 002 2h2m0 0v1a2 2 0 002 2h6a2 2 0 002-2v-1m0 0H7m0 0h10" />
                </svg>
                <span>Print Report</span>
            </button>
        </div>

        <!-- Report Table -->
        <div class="overflow-x-auto rounded-lg shadow-md border border-gray-200">
            <table class="min-w-full bg-white">
                <thead>
                    <!-- This header is just for screen readers/initial structure, actual headers are per athlete -->
                    <tr>
                        <th class="hidden">Athlete Details</th>
                        <th class="hidden">Event</th>
                        <th class="hidden">Seed Time</th>
                        <th class="hidden">Final Time</th>
                        <th class="hidden">Place</th>
                        <th class="hidden">Points</th>
                        <th class="hidden">% Improvement</th>
                    </tr>
                </thead>
                <tbody id="reportTableBody" class="bg-white divide-y divide-gray-200">
                    <!-- Data will be populated here by JavaScript -->
                </tbody>
            </table>
        </div>
    </div>

    <script>
        // Helper function to convert time string (MM:SS.ms or SS.ms) to seconds
        function timeToSeconds(timeStr) {
            if (!timeStr || timeStr === 'NS' || timeStr === 'DQ') return Infinity;
            const parts = String(timeStr).split(':'); // Ensure timeStr is a string
            if (parts.length === 2) {
                const minutes = parseInt(parts[0]);
                const seconds = parseFloat(parts[1]);
                return minutes * 60 + seconds;
            } else if (parts.length === 1) {
                return parseFloat(parts[0]); // Handles cases like "28.15" if no minutes
            }
            return Infinity; // Invalid format
        }

        // Helper function to convert seconds to time string (MM:SS.ms)
        function secondsToTime(totalSeconds) {
            if (totalSeconds === Infinity || isNaN(totalSeconds)) return 'N/A';
            const minutes = Math.floor(totalSeconds / 60);
            const seconds = totalSeconds % 60;
            // Pad seconds with leading zero if less than 10, and ensure two decimal places
            return `${minutes}:${seconds < 10 ? '0' : ''}${seconds.toFixed(2)}`;
        }

        // Helper to format date for display (e.g., "June 8")
        function formatDate(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString('en-US', { month: 'long', day: 'numeric' });
        }

        // --- Simulated JSON Data ---
        // In a real application, you would load these from actual files via fetch().
        const simulatedJsonData = {
            "2025resultsweek01.json": [
                { id: 1, lastName: "Smith", firstName: "Alice", category: "Female", age: 14, eventSwum: "100m Freestyle", seedTime: "1:02.50", resultTime: "1:01.80", meetDate: "2025-06-08", place: 1, points: 50 },
                { id: 1, lastName: "Smith", firstName: "Alice", category: "Female", age: 14, eventSwum: "50m Freestyle", seedTime: "0:28.00", resultTime: "0:27.50", meetDate: "2025-06-08", place: 2, points: 45 },
                { id: 2, lastName: "Johnson", firstName: "Bob", category: "Male", age: 22, eventSwum: "50m Backstroke", seedTime: "0:28.15", resultTime: "0:27.90", meetDate: "2025-06-08", place: 1, points: 60 },
                { id: 11, lastName: "Hubbard", firstName: "Zachary", category: "Male", age: 18, eventSwum: "50m Breaststroke", seedTime: "0:31.12", resultTime: "0:30.98", meetDate: "2025-06-08", place: 1, points: 8 },
                { id: 11, lastName: "Hubbard", firstName: "Zachary", category: "Male", age: 18, eventSwum: "100m Freestyle", seedTime: "0:55.00", resultTime: "0:54.50", meetDate: "2025-06-08", place: 2, points: 7 },
            ],
            "2025resultsweek02.json": [
                { id: 1, lastName: "Smith", firstName: "Alice", category: "Female", age: 14, eventSwum: "100m Freestyle", seedTime: "1:01.00", resultTime: "1:00.50", meetDate: "2025-06-15", place: 1, points: 50 },
                { id: 1, lastName: "Smith", firstName: "Alice", category: "Female", age: 14, eventSwum: "100m Backstroke", seedTime: "1:12.00", resultTime: "1:11.50", meetDate: "2025-06-15", place: 2, points: 40 },
                { id: 2, lastName: "Johnson", firstName: "Bob", category: "Male", age: 22, eventSwum: "100m Backstroke", seedTime: "0:59.00", resultTime: "0:58.80", meetDate: "2025-06-15", place: 1, points: 60 },
                { id: 3, lastName: "Williams", firstName: "Charlie", category: "Male", age: 15, eventSwum: "200m IM", seedTime: "2:30.00", resultTime: "2:29.00", meetDate: "2025-06-15", place: 1, points: 50 },
                { id: 11, lastName: "Hubbard", firstName: "Zachary", category: "Male", age: 18, eventSwum: "50m Breaststroke", seedTime: "0:31.00", resultTime: "0:30.50", meetDate: "2025-06-15", place: 1, points: 9 },
            ],
            "2025resultsweek03.json": [
                { id: 1, lastName: "Smith", firstName: "Alice", category: "Female", age: 15, eventSwum: "50m Freestyle", seedTime: "0:26.50", resultTime: "0:26.20", meetDate: "2025-06-22", place: 1, points: 55 },
                { id: 2, lastName: "Johnson", firstName: "Bob", category: "Male", age: 22, eventSwum: "200m Backstroke", seedTime: "2:10.00", resultTime: "2:09.50", meetDate: "2025-06-22", place: 1, points: 65 },
                { id: 4, lastName: "Jones", firstName: "Diana", category: "Female", age: 46, eventSwum: "50m Breaststroke", seedTime: "0:37.00", resultTime: "0:36.80", meetDate: "2025-06-22", place: 1, points: 45 },
            ]
        };
        // --- End Simulated JSON Data ---

        let allAthleteData = []; // This will now be populated dynamically
        let filteredAthleteData = [];

        const reportTableBody = document.getElementById('reportTableBody');
        const filterNameInput = document.getElementById('filterName');
        const filterCategoryInput = document.getElementById('filterCategory');
        const filterEventInput = document.getElementById('filterEvent');
        const filterStartDateInput = document.getElementById('filterStartDate');
        const filterEndDateInput = document.getElementById('filterEndDate');
        const applyFiltersButton = document.getElementById('applyFilters');
        const resetFiltersButton = document.getElementById('resetFilters');
        const printReportButton = document.getElementById('printReport');
        const selectSwimmer = document.getElementById('selectSwimmer');
        const jsonFileSelector = document.getElementById('jsonFileSelector');

        let specialtyChartInstance = null;
        let progressionChartInstance = null;

        /**
         * Populates the JSON file selector with options including date ranges.
         */
        function populateJsonFileSelector() {
            // Clear existing options
            jsonFileSelector.innerHTML = '';

            // Add week-specific options with calculated date ranges
            const fileNames = Object.keys(simulatedJsonData);
            fileNames.forEach(fileName => {
                const weekData = simulatedJsonData[fileName];
                if (weekData.length > 0) {
                    // Assuming the meetDate of the first entry represents the start of the week for display
                    const startDate = weekData[0].meetDate;
                    const dateObj = new Date(startDate);
                    // Calculate end date (6 days after start date for a full week, as example)
                    const endDateObj = new Date(dateObj);
                    endDateObj.setDate(dateObj.getDate() + 6);

                    const option = document.createElement('option');
                    option.value = fileName;
                    option.textContent = `${fileName.replace('.json', '')} - ${formatDate(startDate)} - ${formatDate(endDateObj.toISOString().split('T')[0])}`;
                    jsonFileSelector.appendChild(option);
                }
            });

            // Add the "All Results" option last
            const allResultsOption = document.createElement('option');
            allResultsOption.value = "all-results";
            allResultsOption.textContent = "All Results (All Weeks)";
            jsonFileSelector.appendChild(allResultsOption);
        }

        /**
         * Fetches data from a simulated JSON file(s) and updates the report.
         * In a real application, this would use `fetch(url)` to load actual files.
         * @param {string} fileName - The name of the JSON file to load, or "all-results".
         */
        async function fetchAndRenderData(fileName) {
            let dataToLoad = [];
            if (fileName === "all-results") {
                // Concatenate all data from all simulated weeks
                for (const weekData of Object.values(simulatedJsonData)) {
                    dataToLoad = dataToLoad.concat(weekData);
                }
            } else {
                // Load data for a specific week
                dataToLoad = simulatedJsonData[fileName];
            }

            if (dataToLoad) {
                allAthleteData = dataToLoad;
                applyFilters(); // Apply current filters (including date filters) after new data loads
                populateSwimmerSelect(); // Repopulate swimmer select based on new data
                // Clear and update charts if a swimmer was previously selected
                if (selectSwimmer.value) {
                    updateSpecialtyChart(selectSwimmer.value);
                    updateProgressionChart(selectSwimmer.value);
                } else {
                    // Clear charts if no swimmer selected
                    if (specialtyChartInstance) specialtyChartInstance.destroy();
                    if (progressionChartInstance) progressionChartInstance.destroy();
                }
            } else {
                console.error(`Error: Data for ${fileName} not found in simulated data.`);
                allAthleteData = [];
                filteredAthleteData = [];
                renderTable(filteredAthleteData);
                populateSwimmerSelect();
                if (specialtyChartInstance) specialtyChartInstance.destroy();
                if (progressionChartInstance) progressionChartInstance.destroy();
            }
        }

        /**
         * Renders the athlete data into the table, grouped by athlete.
         * @param {Array<Object>} data - The array of athlete data to render.
         */
        function renderTable(data) {
            reportTableBody.innerHTML = ''; // Clear existing rows

            // Group data by athlete
            const athletesGrouped = data.reduce((acc, current) => {
                const key = `${current.lastName}, ${current.firstName} (${current.age}) - ${current.category}`;
                if (!acc[key]) {
                    acc[key] = {
                        id: current.id, // Store ID for chart selection
                        details: {
                            lastName: current.lastName,
                            firstName: current.firstName,
                            age: current.age,
                            category: current.category // This is 'gender' from SQL
                        },
                        events: []
                    };
                }
                acc[key].events.push(current);
                return acc;
            }, {});

            const athleteKeys = Object.keys(athletesGrouped).sort(); // Sort athletes alphabetically

            if (athleteKeys.length === 0) {
                const noResultsRow = document.createElement('tr');
                // Colspan needs to be adjusted based on the new total columns (6 for events + 1 for main header)
                noResultsRow.innerHTML = `
                    <td colspan="7" class="px-6 py-4 whitespace-nowrap text-sm text-gray-500 text-center">
                        No results found matching your filters.
                    </td>
                `;
                reportTableBody.appendChild(noResultsRow);
                return;
            }

            athleteKeys.forEach(athleteKey => {
                const athlete = athletesGrouped[athleteKey];

                // Athlete Header Row
                const athleteHeaderRow = document.createElement('tr');
                athleteHeaderRow.className = 'athlete-header-row';
                athleteHeaderRow.innerHTML = `
                    <td colspan="7" class="px-6 py-3">${athlete.details.lastName}, ${athlete.details.firstName} (${athlete.details.age}) - ${athlete.details.category}</td>
                `;
                reportTableBody.appendChild(athleteHeaderRow);

                // Event Sub-Header Row
                const eventSubHeaderRow = document.createElement('tr');
                eventSubHeaderRow.className = 'event-subheader-row';
                eventSubHeaderRow.innerHTML = `
                    <th>Event</th>
                    <th>Seed</th>
                    <th>Final</th>
                    <th>Place</th>
                    <th>Points</th>
                    <th>% Improvement</th>
                `;
                // Add an empty th to align with the first column of the athlete header
                const emptyTh = document.createElement('th');
                emptyTh.style.width = '1%'; // Small width to avoid large gap
                eventSubHeaderRow.prepend(emptyTh);
                reportTableBody.appendChild(eventSubHeaderRow);

                // Sort events by meetDate and then eventSwum
                athlete.events.sort((a, b) => {
                    const dateA = new Date(a.meetDate);
                    const dateB = new Date(b.meetDate);
                    if (dateA.getTime() !== dateB.getTime()) {
                        return dateA - dateB;
                    }
                    return a.eventSwum.localeCompare(b.eventSwum);
                });

                // Event Data Rows
                athlete.events.forEach(eventData => {
                    const seedSeconds = timeToSeconds(eventData.seedTime);
                    const resultSeconds = timeToSeconds(eventData.resultTime);

                    let improvement = 'N/A';
                    if (seedSeconds !== Infinity && resultSeconds !== Infinity && seedSeconds > 0) {
                        improvement = (((seedSeconds - resultSeconds) / seedSeconds) * 100).toFixed(2);
                        // Add a plus sign for positive improvement, for clarity
                        if (parseFloat(improvement) > 0) {
                             improvement = `+${improvement}%`;
                        } else {
                             improvement = `${improvement}%`;
                        }
                    }

                    const eventRow = document.createElement('tr');
                    eventRow.className = 'event-data-row hover:bg-gray-50 transition duration-150 ease-in-out';
                    eventRow.innerHTML = `
                        <td>${eventData.eventSwum}</td>
                        <td>${eventData.seedTime}</td>
                        <td>${eventData.resultTime}</td>
                        <td>${eventData.place}</td>
                        <td>${eventData.points}</td>
                        <td>${improvement}</td>
                    `;
                    // Add an empty td for alignment with the first column of the athlete header
                    const emptyTd = document.createElement('td');
                    eventRow.prepend(emptyTd);
                    reportTableBody.appendChild(eventRow);
                });
            });
        }

        /**
         * Initializes the swimmer selection dropdown.
         */
        function populateSwimmerSelect() {
            // Clear existing options, but keep the default "Select an Athlete"
            while (selectSwimmer.children.length > 1) {
                selectSwimmer.removeChild(selectSwimmer.lastChild);
            }

            const uniqueSwimmers = [];
            const swimmerMap = new Map(); // Using a map to track unique swimmer by ID and name

            allAthleteData.forEach(athlete => {
                const key = `${athlete.id}-${athlete.firstName}-${athlete.lastName}`;
                if (!swimmerMap.has(key)) {
                    swimmerMap.set(key, {
                        id: athlete.id,
                        firstName: athlete.firstName,
                        lastName: athlete.lastName
                    });
                    uniqueSwimmers.push({
                        id: athlete.id,
                        fullName: `${athlete.firstName} ${athlete.lastName}`
                    });
                }
            });

            // Sort swimmers alphabetically by full name
            uniqueSwimmers.sort((a, b) => a.fullName.localeCompare(b.fullName));

            uniqueSwimmers.forEach(swimmer => {
                const option = document.createElement('option');
                option.value = swimmer.id;
                option.textContent = swimmer.fullName;
                selectSwimmer.appendChild(option);
            });
        }

        /**
         * Generates data for the Specialty (Radar) Chart for a given swimmer.
         * For mock data, this generates a plausible but arbitrary "specialty" profile.
         * In a real app, this would analyze actual performance across strokes.
         */
        function getSpecialtyChartData(swimmerId) {
            const swimmerData = allAthleteData.filter(d => d.id == swimmerId);
            if (swimmerData.length === 0) return null;

            const strokes = ['Freestyle', 'Backstroke', 'Breaststroke', 'Butterfly', 'IM'];
            const specialtyScores = {};
            strokes.forEach(stroke => {
                // Filter for events containing the stroke, ignoring distance for this general specialty score
                const relevantEvents = swimmerData.filter(d => d.eventSwum.toLowerCase().includes(stroke.toLowerCase()) && d.resultTime !== 'NS' && d.resultTime !== 'DQ');
                if (relevantEvents.length > 0) {
                    // Calculate average time in seconds for this stroke
                    const sumTimes = relevantEvents.reduce((sum, d) => sum + timeToSeconds(d.resultTime), 0);
                    const avgTime = sumTimes / relevantEvents.length;

                    // Normalize the average time into a score (e.g., 0-100)
                    // Lower time is better, so a lower avgTime should yield a higher score.
                    // Max expected average time for a stroke (adjust as needed for your data range)
                    const max_expected_avg_time = 120; // Example: 2 minutes for an average stroke performance
                    let score = (max_expected_avg_time - avgTime) / max_expected_avg_time * 100;
                    score = Math.max(0, Math.min(100, score)); // Clamp between 0 and 100
                    specialtyScores[stroke] = score;
                } else {
                    specialtyScores[stroke] = 0; // If no data for stroke, score is 0
                }
            });

            return {
                labels: strokes,
                datasets: [{
                    label: `${swimmerData[0].firstName} ${swimmerData[0].lastName}'s Specialty`,
                    data: strokes.map(stroke => specialtyScores[stroke]),
                    backgroundColor: 'rgba(153, 102, 255, 0.4)',
                    borderColor: 'rgba(153, 102, 255, 1)',
                    borderWidth: 1,
                    pointBackgroundColor: 'rgba(153, 102, 255, 1)'
                }]
            };
        }

        /**
         * Generates data for the Progression (Line) Chart for a given swimmer and event.
         */
        function getProgressionChartData(swimmerId, eventSwum) {
            const swimmerEventData = allAthleteData
                .filter(d => d.id == swimmerId && d.eventSwum === eventSwum && d.resultTime !== 'NS' && d.resultTime !== 'DQ')
                .sort((a, b) => new Date(a.meetDate) - new Date(b.meetDate)); // Sort by date

            if (swimmerEventData.length === 0) return null;

            return {
                labels: swimmerEventData.map(d => d.meetDate),
                datasets: [{
                    label: `${eventSwum} Time Progression`,
                    data: swimmerEventData.map(d => timeToSeconds(d.resultTime)),
                    fill: false,
                    borderColor: 'rgb(75, 192, 192)',
                    tension: 0.1,
                    pointBackgroundColor: 'rgb(75, 192, 192)'
                }]
            };
        }

        /**
         * Initializes or updates the Specialty (Radar) Chart.
         */
        function updateSpecialtyChart(swimmerId) {
            if (specialtyChartInstance) {
                specialtyChartInstance.destroy(); // Destroy existing chart
            }
            const chartData = getSpecialtyChartData(swimmerId);
            const ctx = document.getElementById('specialtyChart').getContext('2d');

            if (!chartData) {
                ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear canvas
                return;
            }

            specialtyChartInstance = new Chart(ctx, {
                type: 'radar',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        r: {
                            angleLines: {
                                color: '#e2e8f0' // gray-200
                            },
                            grid: {
                                color: '#cbd5e0' // gray-300
                            },
                            pointLabels: {
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                },
                                color: '#4a5568' // gray-700
                            },
                            min: 0,
                            max: 100, // Assuming scores from 0-100
                            ticks: {
                                stepSize: 20,
                                backdropColor: 'rgba(255, 255, 255, 0.75)',
                                color: '#4a5568'
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#4a5568'
                            }
                        },
                        title: {
                            display: false, // Title is in H3 above canvas
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${context.raw.toFixed(1)}`;
                                }
                            }
                        }
                    }
                }
            });
        }

        /**
         * Initializes or updates the Progression (Line) Chart.
         */
        function updateProgressionChart(swimmerId) {
            if (progressionChartInstance) {
                progressionChartInstance.destroy(); // Destroy existing chart
            }

            const swimmerEvents = [...new Set(allAthleteData.filter(d => d.id == swimmerId).map(d => d.eventSwum))];
            const ctx = document.getElementById('progressionChart').getContext('2d');

            if (swimmerEvents.length === 0) {
                 ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear canvas
                 return;
            }

            // For simplicity, we'll pick the first event for now or you can add another dropdown to select event
            const selectedEventForProgression = swimmerEvents[0];
            const chartData = getProgressionChartData(swimmerId, selectedEventForProgression);

            if (!chartData) {
                 ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height); // Clear canvas
                 return;
            }

            progressionChartInstance = new Chart(ctx, {
                type: 'line',
                data: chartData,
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Meet Date',
                                color: '#4a5568'
                            },
                            ticks: {
                                color: '#4a5568'
                            },
                            grid: {
                                color: '#e2e8f0'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Time (Seconds)',
                                color: '#4a5568'
                            },
                            ticks: {
                                color: '#4a5568',
                                callback: function(value, index, values) {
                                    return secondsToTime(value); // Convert seconds back to MM:SS.ms
                                }
                            },
                            grid: {
                                color: '#e2e8f0'
                            },
                            reverse: true, // Lower time is better, so reverse Y-axis
                            min: 0
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top',
                            labels: {
                                color: '#4a5568'
                            }
                        },
                        title: {
                            display: false, // Title is in H3 above canvas
                        },
                         tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `${context.dataset.label}: ${secondsToTime(context.raw)}`;
                                }
                            }
                        }
                    }
                }
            });
        }


        // Filters
        function applyFilters() {
            const nameFilter = filterNameInput.value.toLowerCase();
            const categoryFilter = filterCategoryInput.value.toLowerCase();
            const eventFilter = filterEventInput.value.toLowerCase();
            const startDateStr = filterStartDateInput.value;
            const endDateStr = filterEndDateInput.value;

            // Parse dates, setting to null if empty for optional filtering
            const startDate = startDateStr ? new Date(startDateStr + 'T00:00:00') : null; // Add time to ensure date comparison works correctly
            const endDate = endDateStr ? new Date(endDateStr + 'T23:59:59') : null;     // Add time to ensure date comparison works correctly

            filteredAthleteData = allAthleteData.filter(athlete => {
                const fullName = `${athlete.firstName} ${athlete.lastName}`.toLowerCase();
                const matchesName = nameFilter === '' || fullName.includes(nameFilter) || athlete.lastName.toLowerCase().includes(nameFilter) || athlete.firstName.toLowerCase().includes(nameFilter);
                const matchesCategory = categoryFilter === '' || athlete.category.toLowerCase().includes(categoryFilter);
                const matchesEvent = eventFilter === '' || athlete.eventSwum.toLowerCase().includes(eventFilter);

                let matchesDate = true;
                if (startDate || endDate) {
                    const meetDate = new Date(athlete.meetDate + 'T12:00:00'); // Ensure consistent time for comparison
                    matchesDate = (!startDate || meetDate >= startDate) &&
                                  (!endDate || meetDate <= endDate);
                }

                return matchesName && matchesCategory && matchesEvent && matchesDate;
            });

            renderTable(filteredAthleteData);
        }

        function resetFilters() {
            filterNameInput.value = '';
            filterCategoryInput.value = '';
            filterEventInput.value = '';
            filterStartDateInput.value = ''; // Clear date inputs
            filterEndDateInput.value = '';   // Clear date inputs
            // No need to reload data from JSON here, just re-apply filters on current allAthleteData
            filteredAthleteData = [...allAthleteData];
            renderTable(filteredAthleteData);
        }

        // Event Listeners
        applyFiltersButton.addEventListener('click', applyFilters);
        resetFiltersButton.addEventListener('click', resetFilters);
        printReportButton.addEventListener('click', () => {
            window.print();
        });

        selectSwimmer.addEventListener('change', (event) => {
            const selectedSwimmerId = event.target.value;
            if (selectedSwimmerId) {
                updateSpecialtyChart(selectedSwimmerId);
                updateProgressionChart(selectedSwimmerId);
            } else {
                // Clear charts if no swimmer selected
                if (specialtyChartInstance) specialtyChartInstance.destroy();
                if (progressionChartInstance) progressionChartInstance.destroy();
            }
        });

        // Event listener for JSON file selection
        jsonFileSelector.addEventListener('change', (event) => {
            // Reset text/category/event filters completely when changing the data source (file)
            filterNameInput.value = '';
            filterCategoryInput.value = '';
            filterEventInput.value = '';
            // Don't clear date inputs here if user wants to keep a date range selected
            // You might want to adjust this behavior based on user preference
            fetchAndRenderData(event.target.value);
        });

        // Initial render on page load: populate selector, then load default data
        document.addEventListener('DOMContentLoaded', () => {
            populateJsonFileSelector();
            const defaultFile = jsonFileSelector.value; // Get the initially selected value
            fetchAndRenderData(defaultFile);
        });
    </script>
</body>
</html>

